# ModuForge-RS å¤–éƒ¨é¡¹ç›®é›†æˆè§„åˆ™
# åŸºäº Rust çš„çŠ¶æ€ç®¡ç†å’Œæ•°æ®è½¬æ¢æ¡†æ¶

## é¡¹ç›®æ¦‚è¿°
ModuForge-RS æ˜¯ä¸€ä¸ªåŸºäº Rust çš„ç°ä»£åŒ–çŠ¶æ€ç®¡ç†å’Œæ•°æ®è½¬æ¢æ¡†æ¶ï¼Œé‡‡ç”¨ä¸å¯å˜æ•°æ®ç»“æ„å’Œäº‹ä»¶é©±åŠ¨æ¶æ„ã€‚è¯¥æ¡†æ¶æä¾›äº†å®Œæ•´çš„æ’ä»¶ç³»ç»Ÿã€ä¸­é—´ä»¶æ”¯æŒã€è§„åˆ™å¼•æ“é›†æˆå’Œåä½œåŠŸèƒ½ã€‚

## æ ¸å¿ƒæ¶æ„ç»„ä»¶

### 1. æ ¸å¿ƒæ¨¡å— (moduforge-core)
- **å¼‚æ­¥å¤„ç†å™¨**: æä¾›é«˜æ€§èƒ½çš„å¼‚æ­¥ä»»åŠ¡å¤„ç†èƒ½åŠ›
- **äº‹ä»¶ç³»ç»Ÿ**: ç±»å‹å®‰å…¨çš„äº‹ä»¶åˆ†å‘å’Œå¤„ç†æœºåˆ¶
- **æ‰©å±•æœºåˆ¶**: çµæ´»çš„æ’ä»¶å’Œæ‰©å±•åŠ è½½ç³»ç»Ÿ
- **ä¸­é—´ä»¶æ”¯æŒ**: å¯é…ç½®çš„è¯·æ±‚/å“åº”å¤„ç†ç®¡é“
- **æµç¨‹æ§åˆ¶**: åŒæ­¥å’Œå¼‚æ­¥æµç¨‹ç®¡ç†

### 2. æ•°æ®æ¨¡å‹ (moduforge-model)
- **èŠ‚ç‚¹ç³»ç»Ÿ**: å±‚æ¬¡åŒ–çš„æ–‡æ¡£èŠ‚ç‚¹ç»“æ„
- **æ ‡è®°ç³»ç»Ÿ**: æ–‡æ¡£æ ¼å¼åŒ–å’Œå±æ€§æ ‡è®°
- **å±æ€§ç³»ç»Ÿ**: ç±»å‹å®‰å…¨çš„å±æ€§ç®¡ç†
- **æ¨¡å¼å®šä¹‰**: æ–‡æ¡£ç»“æ„éªŒè¯å’Œçº¦æŸ
- **å†…å®¹åŒ¹é…**: æ™ºèƒ½å†…å®¹éªŒè¯å’ŒåŒ¹é…

### 3. çŠ¶æ€ç®¡ç† (moduforge-state)
- **ä¸å¯å˜çŠ¶æ€**: åŸºäº im-rs çš„æŒä¹…åŒ–æ•°æ®ç»“æ„
- **äº‹åŠ¡å¤„ç†**: ACID å…¼å®¹çš„äº‹åŠ¡ç³»ç»Ÿ
- **èµ„æºç®¡ç†**: å…¨å±€èµ„æºè¡¨å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†
- **æ’ä»¶ç³»ç»Ÿ**: åŠ¨æ€æ’ä»¶åŠ è½½å’ŒçŠ¶æ€éš”ç¦»
- **æ—¥å¿—ç³»ç»Ÿ**: ç»“æ„åŒ–æ—¥å¿—å’Œæ€§èƒ½ç›‘æ§

### 4. è§„åˆ™å¼•æ“ (moduforge-rules-engine)
- **å†³ç­–å¼•æ“**: åŸºäº GoRules JDM æ ‡å‡†çš„ä¸šåŠ¡è§„åˆ™å¼•æ“
- **è¡¨è¾¾å¼è¯­è¨€**: é«˜æ€§èƒ½çš„è¡¨è¾¾å¼æ±‚å€¼ç³»ç»Ÿ
- **å‡½æ•°ç³»ç»Ÿ**: å†…ç½®å‡½æ•°ã€è‡ªå®šä¹‰å‡½æ•°å’Œæ–¹æ³•æ”¯æŒ
- **åŠ è½½å™¨ç³»ç»Ÿ**: æ–‡ä»¶ç³»ç»Ÿã€å†…å­˜ã€é—­åŒ…ç­‰å¤šç§åŠ è½½æ–¹å¼
- **å›¾æ‰§è¡Œ**: å¤æ‚çš„å†³ç­–å›¾æ‰§è¡Œå’Œè¿½è¸ª

### 5. è¡¨è¾¾å¼ç³»ç»Ÿ (moduforge-rules-expression)
- **è½»é‡çº§è¯­è¨€**: ä¸“ä¸ºé«˜æ€§èƒ½è®¾è®¡çš„è¡¨è¾¾å¼è¯­è¨€
- **ç±»å‹ç³»ç»Ÿ**: å®Œæ•´çš„ç±»å‹æ£€æŸ¥å’Œæ¨æ–­
- **è‡ªå®šä¹‰å‡½æ•°**: æ”¯æŒç”¨æˆ·å®šä¹‰çš„æ‰©å±•å‡½æ•°
- **æ™ºèƒ½æ„ŸçŸ¥**: ä»£ç è¡¥å…¨å’Œç±»å‹æç¤º
- **WASM æ”¯æŒ**: å¯ç¼–è¯‘åˆ° WebAssembly

### 6. æ•°æ®è½¬æ¢ (moduforge-transform)
- **èŠ‚ç‚¹æ“ä½œ**: æ·»åŠ ã€ç§»åŠ¨ã€åˆ é™¤ã€æ›¿æ¢èŠ‚ç‚¹
- **æ ‡è®°æ“ä½œ**: æ ‡è®°çš„æ·»åŠ å’Œåˆ é™¤
- **å±æ€§æ›´æ–°**: æ‰¹é‡å±æ€§ä¿®æ”¹
- **è¡¥ä¸ç³»ç»Ÿ**: å¢é‡æ›´æ–°å’Œå†…å­˜ä¼˜åŒ–
- **æ‰¹é‡æ“ä½œ**: é«˜æ•ˆçš„æ‰¹é‡è½¬æ¢å¤„ç†

### 7. åä½œç³»ç»Ÿ (moduforge-collaboration)
- **å®æ—¶åŒæ­¥**: åŸºäº Yrs çš„å®æ—¶åä½œ
- **WebSocket æœåŠ¡**: é«˜æ€§èƒ½çš„ WebSocket æœåŠ¡å™¨
- **å†²çªè§£å†³**: è‡ªåŠ¨å†²çªæ£€æµ‹å’Œè§£å†³
- **æˆ¿é—´ç®¡ç†**: å¤šæˆ¿é—´åä½œæ”¯æŒ
- **çŠ¶æ€æ˜ å°„**: æ–‡æ¡£çŠ¶æ€åˆ°åä½œçŠ¶æ€çš„æ˜ å°„

### 8. æ¨¡æ¿ç³»ç»Ÿ (moduforge-template)
- **æ¨¡æ¿æ¸²æŸ“**: åŸºäºè¡¨è¾¾å¼çš„æ¨¡æ¿ç³»ç»Ÿ
- **è¯æ³•åˆ†æ**: é«˜æ•ˆçš„æ¨¡æ¿è§£æ
- **ä¸Šä¸‹æ–‡æ”¯æŒ**: åŠ¨æ€ä¸Šä¸‹æ–‡å˜é‡æ³¨å…¥

## æŠ€æœ¯æ ˆå’Œä¾èµ–

### æ ¸å¿ƒä¾èµ–
```toml
[dependencies]
# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.0", features = ["full"] }
async-trait = "0.1"

# ä¸å¯å˜æ•°æ®ç»“æ„
im = { version = "15.1", features = ["serde"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive", "rc"] }
serde_json = "1.0"

# é”™è¯¯å¤„ç†
anyhow = "1"
thiserror = "2.0.12"

# å¹¶å‘å’ŒåŒæ­¥
dashmap = "6.1.0"
async-channel = "2.3.1"
crossbeam = "0.8"
parking_lot = "0.12"

# æ—¥å¿—å’Œç›‘æ§
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# å·¥å…·åº“
uuid = { version = "1.0", features = ["v4"] }
chrono = "0.4"
rayon = "1.8"
lru = "0.14.0"
ahash = "0.8"
rust_decimal = "1"

# ModuForge-RS æ ¸å¿ƒåŒ…
moduforge-core = "0.4.8"
moduforge-state = "0.4.8"
moduforge-model = "0.4.8"
moduforge-transform = "0.4.8"
moduforge-rules-engine = "0.4.8"
moduforge-rules-expression = "0.4.8"
moduforge-collaboration = "0.4.8"
moduforge-template = "0.4.8"
```

## ä»£ç é£æ ¼æŒ‡å—

### Rust çº¦å®š
- éµå¾ªæ ‡å‡† Rust å‘½åçº¦å®šï¼ˆsnake_case å˜é‡/å‡½æ•°ï¼ŒPascalCase ç±»å‹ï¼‰
- ä½¿ç”¨ `clippy` è­¦å‘Šå’Œå»ºè®®
- ä¼˜å…ˆä½¿ç”¨æ˜¾å¼é”™è¯¯å¤„ç†è€Œé panic
- ä½¿ç”¨ `Result<T, E>` è¿›è¡Œå¯å¤±è´¥æ“ä½œ
- ä¸ºæ‰€æœ‰è‡ªå®šä¹‰ç±»å‹å®ç° `Debug`ã€`Clone`ã€`PartialEq` æ´¾ç”Ÿ
- é™¤éæœ‰ç‰¹æ®ŠåŸå› ï¼Œå¦åˆ™ä¸ºæ‰€æœ‰è‡ªå®šä¹‰ç±»å‹ä½¿ç”¨ `#[derive(Debug)]`

### é¡¹ç›®ç‰¹å®šæ¨¡å¼
- ä½¿ç”¨ `im::HashMap` å’Œ `im::Vector` ä½œä¸ºä¸å¯å˜é›†åˆ
- äº‹ä»¶é©±åŠ¨æ¶æ„ï¼šæ‰€æœ‰çŠ¶æ€å˜æ›´éƒ½åº”å‘å‡ºäº‹ä»¶
- åŸºäºäº‹åŠ¡çš„æ“ä½œï¼šå°†ç›¸å…³å˜æ›´åˆ†ç»„åˆ°äº‹åŠ¡ä¸­
- æ’ä»¶æ¶æ„ï¼šå®ç°å¯æ‰©å±•çš„æ’ä»¶ç³»ç»Ÿ
- ä¸­é—´ä»¶æ¨¡å¼ï¼šä½¿ç”¨ä¸­é—´ä»¶å¤„ç†æ¨ªåˆ‡å…³æ³¨ç‚¹

### é”™è¯¯å¤„ç†
- ä½¿ç”¨ `thiserror` å®šä¹‰è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- ä½¿ç”¨ `anyhow` è¿›è¡Œåº”ç”¨çº§é”™è¯¯å¤„ç†
- å½“å·²çŸ¥é”™è¯¯åŸå› æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨ `Result` è€Œé `Option`
- å§‹ç»ˆæä¾›æœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯
- ä½¿ç”¨ `?` æ“ä½œç¬¦è¿›è¡Œé”™è¯¯ä¼ æ’­

### å†…å­˜ç®¡ç†
- å°½å¯èƒ½ä¼˜å…ˆä½¿ç”¨å€Ÿç”¨è€Œéå…‹éš†
- åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ `Arc<T>` è¿›è¡Œå…±äº«æ‰€æœ‰æƒ
- åœ¨å•çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ `Rc<T>` è¿›è¡Œå…±äº«æ‰€æœ‰æƒ
- å¿…è¦æ—¶æ˜ç¡®æŒ‡å®šç”Ÿå‘½å‘¨æœŸ

## æ¶æ„æ¨¡å¼

### çŠ¶æ€ç®¡ç†
- ä½¿ç”¨ im-rs é›†åˆçš„ä¸å¯å˜çŠ¶æ€
- é€šè¿‡äº‹ä»¶è¿›è¡ŒçŠ¶æ€è½¬æ¢
- åŸºäºå¿«ç…§çš„çŠ¶æ€æŒä¹…åŒ–
- æ—¶é—´æ—…è¡Œè°ƒè¯•èƒ½åŠ›

### äº‹ä»¶ç³»ç»Ÿ
- äº‹ä»¶é©±åŠ¨æ¶æ„
- ç±»å‹å®‰å…¨çš„äº‹ä»¶åˆ†å‘
- ç”¨äºçŠ¶æ€é‡å»ºçš„äº‹ä»¶æº¯æº
- äº‹ä»¶é‡æ”¾èƒ½åŠ›

### æ’ä»¶ç³»ç»Ÿ
- åŠ¨æ€æ’ä»¶åŠ è½½
- æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ’ä»¶ä¾èµ–è§£æ
- æ’ä»¶éš”ç¦»å’Œæ²™ç®±åŒ–

### äº‹åŠ¡æ¨¡å‹
- ACID å…¼å®¹çš„äº‹åŠ¡
- å›æ»šèƒ½åŠ›
- äº‹åŠ¡æ—¥å¿—è®°å½•
- å¹¶å‘äº‹åŠ¡å¤„ç†

## ä»£ç ç»„ç»‡

### æ¨¡å—ç»“æ„
```
src/
â”œâ”€â”€ core/           # æ ¸å¿ƒæ¡†æ¶ç»„ä»¶
â”œâ”€â”€ events/         # äº‹ä»¶ç³»ç»Ÿå®ç°
â”œâ”€â”€ plugins/        # æ’ä»¶ç³»ç»Ÿ
â”œâ”€â”€ middleware/     # ä¸­é—´ä»¶ç»„ä»¶
â”œâ”€â”€ state/          # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ transactions/   # äº‹åŠ¡å¤„ç†
â”œâ”€â”€ rules/          # è§„åˆ™å¼•æ“é›†æˆ
â””â”€â”€ utils/          # å·¥å…·å‡½æ•°
```

### æ–‡ä»¶å‘½å
- ä½¿ç”¨åæ˜ æ¨¡å—ç”¨é€”çš„æè¿°æ€§åç§°
- åœ¨æ¨¡å—ä¸­åˆ†ç»„ç›¸å…³åŠŸèƒ½
- ä½¿ç”¨ `mod.rs` è¿›è¡Œæ¨¡å—å£°æ˜
- ä¿æŒæ–‡ä»¶å¤§å°å¯ç®¡ç†ï¼ˆå°½å¯èƒ½åœ¨ 500 è¡Œä»¥ä¸‹ï¼‰

## æµ‹è¯•æŒ‡å—
- ä¸ºæ‰€æœ‰å…¬å…± API ç¼–å†™å•å…ƒæµ‹è¯•
- åœ¨é€‚å½“æ—¶ä½¿ç”¨ quickcheck è¿›è¡ŒåŸºäºå±æ€§çš„æµ‹è¯•
- ç«¯åˆ°ç«¯å·¥ä½œæµçš„é›†æˆæµ‹è¯•
- æ¨¡æ‹Ÿå¤–éƒ¨ä¾èµ–
- æµ‹è¯•é”™è¯¯æ¡ä»¶å’Œè¾¹ç¼˜æƒ…å†µ
- ä½¿ç”¨ `#[cfg(test)]` æ ‡è®°ä»…æµ‹è¯•ä»£ç 

## æ€§èƒ½è€ƒè™‘
- åœ¨çƒ­è·¯å¾„ä¸­æœ€å°åŒ–åˆ†é…
- å°½å¯èƒ½ä½¿ç”¨é›¶æ‹·è´æ“ä½œ
- åœ¨ä¼˜åŒ–å‰è¿›è¡Œæ€§èƒ½åˆ†æ
- è€ƒè™‘å¯¹å°å‹é›†åˆä½¿ç”¨ `smallvec`
- å¯¹ä¸å¯å˜å­—ç¬¦ä¸²ä½¿ç”¨ `Box<str>` è€Œé `String`
- å¯¹æ˜‚è´µè®¡ç®—ä½¿ç”¨æƒ°æ€§æ±‚å€¼

## æ–‡æ¡£
- ä½¿ç”¨ `///` è¿›è¡Œå…¬å…± API æ–‡æ¡£
- åœ¨æ–‡æ¡£ä¸­åŒ…å«ç¤ºä¾‹
- è®°å½•é”™è¯¯æ¡ä»¶
- è§£é‡Šå¤æ‚ç®—æ³•
- ä¿æŒ README.md ä¸å½“å‰åŠŸèƒ½åŒæ­¥

## ä¾èµ–ç®¡ç†
- æœ€å°åŒ–å¤–éƒ¨ä¾èµ–
- åœ¨ Cargo.lock ä¸­å›ºå®šä¾èµ–ç‰ˆæœ¬
- å®šæœŸå®¡è®¡ä¾èµ–çš„å®‰å…¨æ€§
- ä¼˜å…ˆé€‰æ‹©æœ‰è‰¯å¥½æ–‡æ¡£çš„ç»´æŠ¤è‰¯å¥½çš„ crate
- å¯¹ç®€å•åŠŸèƒ½è€ƒè™‘å†…éƒ¨æ›¿ä»£æ–¹æ¡ˆ

## å¼‚æ­¥ç¼–ç¨‹
- å¯¹ I/O æ“ä½œä½¿ç”¨ `async/await`
- å¯¹ CPU å¯†é›†å‹ä»»åŠ¡ä¼˜å…ˆä½¿ç”¨ `tokio::spawn`
- å¯¹å…±äº«å¯å˜çŠ¶æ€ä½¿ç”¨ `Arc<Mutex<T>>` æˆ– `Arc<RwLock<T>>`
- é¿å…åœ¨å¼‚æ­¥ä¸Šä¸‹æ–‡ä¸­è¿›è¡Œé˜»å¡æ“ä½œ
- ä½¿ç”¨é€šé“è¿›è¡Œä»»åŠ¡é—´é€šä¿¡

## å®‰å…¨è€ƒè™‘
- éªŒè¯æ‰€æœ‰å¤–éƒ¨è¾“å…¥
- ä½¿ç”¨ç±»å‹å®‰å…¨ API é˜²æ­¢å¸¸è§é”™è¯¯
- å®ç°é€‚å½“çš„èº«ä»½éªŒè¯å’Œæˆæƒ
- è®°å½•å®‰å…¨ç›¸å…³äº‹ä»¶
- ä½¿ç”¨å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆ
- é¿å…åœ¨æ—¥å¿—ä¸­å­˜å‚¨æ•æ„Ÿæ•°æ®

## å¸¸è§åæ¨¡å¼é¿å…
- åœ¨ç”Ÿäº§ä»£ç ä¸­æ— ç†ç”±ä½¿ç”¨ `unwrap()` æˆ– `expect()`
- å¿½ç•¥ç¼–è¯‘å™¨è­¦å‘Š
- å¤§å‹å‡½æ•°ï¼ˆä¼˜å…ˆåˆ†è§£ä¸ºè¾ƒå°å‡½æ•°ï¼‰
- æ·±åº¦åµŒå¥—ï¼ˆä½¿ç”¨æ—©æœŸè¿”å›å’Œå®ˆå«å­å¥ï¼‰
- å¯å˜å…¨å±€çŠ¶æ€
- åœ¨å¼‚æ­¥ä»£ç ä¸­è¿›è¡Œé˜»å¡æ“ä½œ

## ç‰¹å®šæ¡†æ¶åŠŸèƒ½

### èŠ‚ç‚¹ç³»ç»Ÿ
- å±‚æ¬¡åŒ–èŠ‚ç‚¹ç»“æ„
- åŸºäºå±æ€§çš„èŠ‚ç‚¹å±æ€§
- åŸºäºæ ‡è®°çš„èŠ‚ç‚¹æ ‡è®°
- èŠ‚ç‚¹éªŒè¯å’Œç±»å‹æ£€æŸ¥

### è§„åˆ™å¼•æ“é›†æˆ
- åŸºäº YAML çš„è§„åˆ™é…ç½®
- åŠ¨æ€è§„åˆ™è¯„ä¼°
- è§„åˆ™ç»„åˆå’Œé“¾æ¥
- è‡ªå®šä¹‰è§„åˆ™éªŒè¯å™¨

### ä¸­é—´ä»¶é“¾
- è¯·æ±‚/å“åº”å¤„ç†ç®¡é“
- å¯é…ç½®çš„ä¸­é—´ä»¶æ’åº
- é”™è¯¯å¤„ç†å’Œæ¢å¤
- æ€§èƒ½ç›‘æ§

### æ’ä»¶æ¶æ„
- æ’ä»¶å‘ç°å’ŒåŠ è½½
- æ’ä»¶é…ç½®ç®¡ç†
- æ’ä»¶ç”Ÿå‘½å‘¨æœŸé’©å­
- æ’ä»¶é€šä¿¡åè®®

## AI åŠ©æ‰‹æŒ‡å—
åœ¨å¸®åŠ©å¤„ç†æ­¤ä»£ç åº“æ—¶ï¼š
1. å§‹ç»ˆè€ƒè™‘ä¸å¯å˜æ•°æ®ç»“æ„èŒƒå¼
2. ä¸ºçŠ¶æ€å˜æ›´å»ºè®®äº‹ä»¶é©±åŠ¨è§£å†³æ–¹æ¡ˆ
3. æ¨èé€‚å½“çš„é”™è¯¯å¤„ç†æ¨¡å¼
4. è€ƒè™‘å»ºè®®çš„æ€§èƒ½å½±å“
5. ä¿æŒä¸ç°æœ‰æ¶æ„æ¨¡å¼çš„ä¸€è‡´æ€§
6. ä¸ºæ–°åŠŸèƒ½å»ºè®®æµ‹è¯•
7. è€ƒè™‘å‘åå…¼å®¹æ€§
8. éµå¾ª Rust æœ€ä½³å®è·µå’Œæƒ¯ç”¨æ³•
9. ä¼˜å…ˆè€ƒè™‘ç±»å‹å®‰å…¨å’Œå†…å­˜å®‰å…¨
10. åœ¨å»ºè®®å˜æ›´æ—¶è€ƒè™‘æ’ä»¶å’Œä¸­é—´ä»¶æ¶æ„

## é›†æˆæœ€ä½³å®è·µ

### åˆå§‹åŒ–æ¡†æ¶
```rust
use mf_core::{AsyncRuntime, RuntimeOptions};
use mf_state::{State, StateConfig};
use mf_core::middleware::MiddlewareStack;

// åˆ›å»ºè¿è¡Œæ—¶é…ç½®
let mut options = RuntimeOptions::default();
options.set_middleware_stack(MiddlewareStack::new());

// åˆ›å»ºçŠ¶æ€é…ç½®
let state_config = StateConfig::default();

// åˆå§‹åŒ–è¿è¡Œæ—¶
let runtime = AsyncRuntime::new(options, state_config).await?;
```

### èŠ‚ç‚¹å®šä¹‰å’Œä½¿ç”¨
```rust
use mf_core::node::Node;
use mf_model::{
    node::Node as ModelNode, 
    attrs::Attrs, 
    types::NodeId,
    node_type::{NodeSpec, NodeEnum},
    schema::AttributeSpec,
    tree::Tree,
    node_pool::NodePool
};
use mf_macro::node;
use std::collections::HashMap;
use serde_json::Value;
use std::sync::Arc;

// 1. ä½¿ç”¨å®å®šä¹‰èŠ‚ç‚¹ï¼ˆé€‚ç”¨äºç®€å•èŠ‚ç‚¹ï¼‰
let paragraph_node = node!(
    "paragraph",
    "æ®µè½èŠ‚ç‚¹",
    "block",
    "level" => 1,
    "style" => "normal"
);

// 2. æ‰‹åŠ¨åˆ›å»ºæ ¸å¿ƒèŠ‚ç‚¹è§„èŒƒ
let mut attrs = HashMap::new();
attrs.insert(
    "align".to_string(),
    AttributeSpec { default: Some(Value::String("left".to_string())) }
);
attrs.insert(
    "indent".to_string(),
    AttributeSpec { default: Some(Value::Number(serde_json::Number::from(0))) }
);

let spec = NodeSpec {
    content: Some("inline".to_string()),
    marks: None,
    attrs: Some(attrs),
    desc: Some("æ®µè½èŠ‚ç‚¹ï¼ŒåŒ…å«æ–‡æœ¬å†…å®¹".to_string()),
    ..Default::default()
};

let core_node = Node::create("paragraph", spec);

// 3. åˆ›å»ºæ¨¡å‹èŠ‚ç‚¹ï¼ˆç”¨äºæ–‡æ¡£æ ‘ï¼‰
let model_node = ModelNode::new(
    "text_1",
    "text".to_string(),
    Attrs::default(),
    vec![], // å­èŠ‚ç‚¹IDåˆ—è¡¨
    vec![]  // æ ‡è®°åˆ—è¡¨
);

// 4. ä»èŠ‚ç‚¹æšä¸¾åˆ›å»ºæ ‘å’ŒèŠ‚ç‚¹æ± 
let root_node = ModelNode::new(
    "root",
    "document".to_string(),
    Attrs::default(),
    vec![],
    vec![]
);

// åˆ›å»ºèŠ‚ç‚¹æšä¸¾ï¼ˆåŒ…å«å±‚æ¬¡ç»“æ„ï¼‰
let node_enum = NodeEnum(root_node, vec![
    NodeEnum(model_node, vec![])
]);

// ä»èŠ‚ç‚¹æšä¸¾åˆ›å»ºæ ‘
let tree = Tree::from(node_enum);

// åˆ›å»ºèŠ‚ç‚¹æ± 
let node_pool = NodePool::new(Arc::new(tree));

// 5. æŸ¥è¯¢å’Œæ“ä½œèŠ‚ç‚¹
let root_node = node_pool.root();
let children = node_pool.children(&root_node.id);
let node_by_id = node_pool.get_node(&NodeId::from("text_1"));
```

### åˆ›å»ºæ’ä»¶
```rust
use mf_state::plugin::{Plugin, PluginSpec, PluginTrait, StateField};
use mf_core::extension::Extension;

#[derive(Debug)]
struct MyPlugin;

#[async_trait]
impl PluginTrait for MyPlugin {
    async fn append_transaction(
        &self,
        transactions: &[Transaction],
        old_state: &State,
        new_state: &State,
    ) -> StateResult<Option<Transaction>> {
        // æ’ä»¶é€»è¾‘
        Ok(None)
    }
}

// åˆ›å»ºæ‰©å±•
let mut extension = Extension::new();
let plugin = Plugin::new(PluginSpec {
    key: ("my_plugin".to_string(), "v1".to_string()),
    tr: Some(Arc::new(MyPlugin)),
    priority: 10,
    state_field: None,
});
extension.add_plugin(Arc::new(plugin));
```

### åˆ›å»ºä¸­é—´ä»¶
```rust
use mf_core::middleware::{Middleware, MiddlewareStack};
use mf_state::{State, Transaction};
use async_trait::async_trait;
use std::sync::Arc;

#[derive(Debug)]
struct LoggingMiddleware {
    name: String,
}

impl LoggingMiddleware {
    pub fn new() -> Self {
        Self { name: "LoggingMiddleware".to_string() }
    }
}

#[async_trait]
impl Middleware for LoggingMiddleware {
    fn name(&self) -> String {
        self.name.clone()
    }

    async fn before_dispatch(
        &self,
        transaction: &mut Transaction,
    ) -> ForgeResult<()> {
        println!("ğŸ” [{}] äº‹åŠ¡å¤„ç†å¼€å§‹ - ID: {}", self.name, transaction.id);
        Ok(())
    }

    async fn after_dispatch(
        &self,
        state: Option<Arc<State>>,
        transactions: &[Transaction],
    ) -> ForgeResult<Option<Transaction>> {
        println!("âœ… [{}] äº‹åŠ¡å¤„ç†å®Œæˆ", self.name);
        Ok(None)
    }
}

// ä½¿ç”¨ä¸­é—´ä»¶
let mut middleware_stack = MiddlewareStack::new();
middleware_stack.add(LoggingMiddleware::new());

// æ·»åŠ åˆ°è¿è¡Œæ—¶é…ç½®
let mut options = RuntimeOptions::default();
options.set_middleware_stack(middleware_stack);
```

### åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
```rust
use mf_core::event::{Event, EventHandler, EventBus};
use mf_state::State;
use async_trait::async_trait;
use std::sync::Arc;

#[derive(Debug)]
struct StateChangeHandler;

#[async_trait]
impl EventHandler<Event> for StateChangeHandler {
    async fn handle(&self, event: &Event) -> ForgeResult<()> {
        match event {
            Event::Create(state) => {
                println!("ğŸ‰ çŠ¶æ€åˆ›å»º: ç‰ˆæœ¬ {}", state.version);
            }
            Event::TrApply(tr_id, transactions, state) => {
                println!("ğŸ“ äº‹åŠ¡åº”ç”¨: ID {}, ç‰ˆæœ¬ {}", tr_id, state.version);
            }
            Event::Destroy => {
                println!("ğŸ—‘ï¸ çŠ¶æ€é”€æ¯");
            }
            Event::Stop => {
                println!("â¹ï¸ çŠ¶æ€åœæ­¢");
            }
        }
        Ok(())
    }
}

// åˆ›å»ºäº‹ä»¶æ€»çº¿
let event_bus = EventBus::<Event>::new();

// æ·»åŠ äº‹ä»¶å¤„ç†å™¨
event_bus.add_event_handler(Arc::new(StateChangeHandler))?;

// å¯åŠ¨äº‹ä»¶å¾ªç¯
event_bus.start_event_loop();

// å¹¿æ’­äº‹ä»¶
event_bus.broadcast(Event::Create(Arc::new(state))).await?;
```

### ä½¿ç”¨è§„åˆ™å¼•æ“
```rust
use mf_rules_engine::{DecisionEngine, EvaluationOptions};
use mf_rules_engine::loader::{FilesystemLoader, FilesystemLoaderOptions};

// åˆ›å»ºå†³ç­–å¼•æ“
let engine = DecisionEngine::new(FilesystemLoader::new(FilesystemLoaderOptions {
    root: "/path/to/decisions",
    keep_in_memory: true,
}));

// è¯„ä¼°å†³ç­–
let context = serde_json::json!({ "input": 42 });
let result = engine.evaluate("my_decision.json", &context).await?;
```

### è¡¨è¾¾å¼æ±‚å€¼
```rust
use mf_rules_expression::{evaluate_expression, Variable};
use serde_json::json;

let context = json!({ "value": 100, "tax_rate": 0.1 });
let result = evaluate_expression("value * tax_rate", context.into())?;
```

### äº‹åŠ¡å¤„ç†
```rust
use mf_state::{Transaction, State};
use mf_transform::{Transform, node_step::AddNodeStep};
use mf_model::{node::Node, types::NodeId};

// åˆ›å»ºäº‹åŠ¡
let mut transaction = Transaction::new();

// æ·»åŠ èŠ‚ç‚¹æ­¥éª¤
let node = Node::new("new_node", "paragraph".to_string(), Attrs::default(), vec![], vec![]);
let add_step = AddNodeStep::new(node, Some(NodeId::from("parent_node")));
transaction.add_step(add_step);

// è®¾ç½®äº‹åŠ¡å…ƒæ•°æ®
transaction.set_meta("action", "add_paragraph");
transaction.set_meta("user_id", "user_123");

// æ‰§è¡Œäº‹åŠ¡
let result = runtime.apply_transaction(transaction).await?;
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### çŠ¶æ€ç®¡ç†
- ä½¿ç”¨ä¸å¯å˜æ•°æ®ç»“æ„å‡å°‘å…‹éš†å¼€é”€
- å®ç°å¢é‡æ›´æ–°ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
- ä½¿ç”¨å¿«ç…§è¿›è¡ŒçŠ¶æ€æŒä¹…åŒ–
- å®ç°çŠ¶æ€åˆ†ç‰‡ä»¥æ”¯æŒå¤§è§„æ¨¡æ•°æ®

### å¼‚æ­¥å¤„ç†
- ä½¿ç”¨é€‚å½“çš„å¹¶å‘çº§åˆ«
- å®ç°èƒŒå‹æœºåˆ¶é˜²æ­¢å†…å­˜æº¢å‡º
- ä½¿ç”¨è¿æ¥æ± ç®¡ç†èµ„æº
- å®ç°è¶…æ—¶å’Œé‡è¯•æœºåˆ¶

### ç¼“å­˜ç­–ç•¥
- å¯¹é¢‘ç¹è®¿é—®çš„æ•°æ®å®ç°ç¼“å­˜
- ä½¿ç”¨ LRU ç¼“å­˜ç®¡ç†å†…å­˜ä½¿ç”¨
- å®ç°ç¼“å­˜å¤±æ•ˆç­–ç•¥
- è€ƒè™‘åˆ†å¸ƒå¼ç¼“å­˜ä»¥æ”¯æŒæ‰©å±•

## ç›‘æ§å’Œè°ƒè¯•

### æ—¥å¿—è®°å½•
```rust
use mf_state::init_logging;

// åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
init_logging("info", Some("logs/app.log"))?;
```

### æ€§èƒ½æŒ‡æ ‡
- ä½¿ç”¨å†…ç½®çš„æŒ‡æ ‡æ”¶é›†
- ç›‘æ§äº‹åŠ¡å¤„ç†æ—¶é—´
- è·Ÿè¸ªå†…å­˜ä½¿ç”¨æƒ…å†µ
- ç›‘æ§æ’ä»¶æ‰§è¡Œæ—¶é—´

### è°ƒè¯•å·¥å…·
- ä½¿ç”¨æ—¶é—´æ—…è¡Œè°ƒè¯•
- å®ç°çŠ¶æ€å¿«ç…§
- ä½¿ç”¨äº‹ä»¶é‡æ”¾åŠŸèƒ½
- å¯ç”¨è¯¦ç»†æ—¥å¿—è®°å½•

## éƒ¨ç½²è€ƒè™‘

### é…ç½®ç®¡ç†
- ä½¿ç”¨ç¯å¢ƒå˜é‡è¿›è¡Œé…ç½®
- å®ç°é…ç½®éªŒè¯
- æ”¯æŒé…ç½®çƒ­é‡è½½
- ä½¿ç”¨é…ç½®æ¨¡æ¿

### å®¹å™¨åŒ–
- åˆ›å»ºå¤šé˜¶æ®µ Dockerfile
- ä¼˜åŒ–é•œåƒå¤§å°
- å®ç°å¥åº·æ£€æŸ¥
- é…ç½®èµ„æºé™åˆ¶

### æ‰©å±•æ€§
- å®ç°æ°´å¹³æ‰©å±•
- ä½¿ç”¨è´Ÿè½½å‡è¡¡
- å®ç°æœåŠ¡å‘ç°
- é…ç½®è‡ªåŠ¨æ‰©ç¼©å®¹ 