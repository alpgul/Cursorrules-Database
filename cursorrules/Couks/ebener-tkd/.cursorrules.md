# Cursor Rules - Ebener TKD Project

Regras de desenvolvimento para o projeto **Ebener TKD**, uma aplicaÃ§Ã£o full-stack para gerenciamento de academia de Taekwondo.

## ğŸš€ Stack TecnolÃ³gico

- **Framework:** Next.js 15 (App Router)
- **Linguagem:** TypeScript
- **Banco de Dados:** PostgreSQL com Prisma ORM
- **AutenticaÃ§Ã£o:** NextAuth.js 4 com Credentials Provider
- **UI:** Tailwind CSS + shadcn/ui + Radix UI
- **Estado:** Zustand (client) + TanStack Query (server state)
- **FormulÃ¡rios:** React Hook Form + Zod validation
- **AnimaÃ§Ãµes:** Framer Motion
- **Ãcones:** Lucide React
- **NotificaÃ§Ãµes:** Sonner (toast)

## ğŸ“ Estrutura do Projeto

```
src/
â”œâ”€â”€ app/                      # App Router do Next.js
â”‚   â”œâ”€â”€ (auth)/              # Grupo de rotas de autenticaÃ§Ã£o
â”‚   â”œâ”€â”€ (dashboard)/         # Grupo de rotas do dashboard
â”‚   â”œâ”€â”€ (pages)/             # Grupo de rotas pÃºblicas
â”‚   â””â”€â”€ api/                 # API Routes
â”œâ”€â”€ components/              # Componentes React
â”‚   â”œâ”€â”€ ui/                  # shadcn/ui components
â”‚   â”œâ”€â”€ auth/                # Componentes de autenticaÃ§Ã£o
â”‚   â”œâ”€â”€ dashboard/           # Componentes do dashboard
â”‚   â””â”€â”€ [feature]/           # Componentes por feature
â”œâ”€â”€ lib/                     # UtilitÃ¡rios e configuraÃ§Ãµes
â”‚   â”œâ”€â”€ auth/                # ConfiguraÃ§Ã£o do NextAuth
â”‚   â”œâ”€â”€ prisma/              # Cliente Prisma
â”‚   â”œâ”€â”€ services/            # Camada de serviÃ§o (business logic)
â”‚   â”œâ”€â”€ validators/          # Schemas Zod
â”‚   â”œâ”€â”€ stores/              # Stores Zustand
â”‚   â”œâ”€â”€ query/               # TanStack Query config
â”‚   â””â”€â”€ providers/           # React Providers
```

## ğŸ—ï¸ Arquitetura e PadrÃµes

### 1. Camada de ServiÃ§o (Business Logic)

- **NUNCA acesse Prisma diretamente das API routes**
- Toda lÃ³gica de negÃ³cio deve estar em `src/lib/services/`
- Cada service deve focar em um Ãºnico recurso do schema
- Use sempre a instÃ¢ncia singleton do Prisma em `src/lib/prisma/client.ts`

**Exemplo correto:**

```typescript
// âŒ NÃ£o faÃ§a isso na API route
const users = await prisma.user.findMany();

// âœ… FaÃ§a isso
const users = await userService.getAllUsers();
```

### 2. API Routes (Next.js App Router)

- Sempre valide entrada com Zod schemas
- Sempre verifique autenticaÃ§Ã£o/autorizaÃ§Ã£o primeiro
- Use funÃ§Ãµes da camada de serviÃ§o para lÃ³gica de negÃ³cio
- Trate erros adequadamente com status codes apropriados

**Template de API Route:**

```typescript
import { NextResponse } from "next/server";
import { getAuthenticatedUser } from "@/lib/auth/session";
import { createUserSchema } from "@/lib/validators/user.schema";
import { userService } from "@/lib/services/user.service";

export async function POST(req: Request) {
  try {
    // 1. Verificar autenticaÃ§Ã£o
    const user = await getAuthenticatedUser();

    // 2. Validar entrada
    const body = await req.json();
    const validation = createUserSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { errors: validation.error.flatten().fieldErrors },
        { status: 400 }
      );
    }

    // 3. Executar lÃ³gica de negÃ³cio
    const result = await userService.create(validation.data);

    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { message: "Internal server error" },
      { status: 500 }
    );
  }
}
```

### 3. AutenticaÃ§Ã£o com NextAuth.js

- ConfiguraÃ§Ã£o centralizada em `src/lib/auth/options.ts`
- Use `getAuthenticatedUser()` para verificar sessÃ£o nas API routes
- Proteja rotas de dashboard com middleware ou verificaÃ§Ã£o no layout
- Tipos customizados para User e Session jÃ¡ estÃ£o configurados

### 4. Componentes React

#### Estrutura de Componentes:

- **UI Components:** `src/components/ui/` (shadcn/ui)
- **Feature Components:** `src/components/[feature]/`
- **Layout Components:** Layouts especÃ­ficos por grupo de rotas

#### PadrÃµes de Componentes:

- Use `"use client"` apenas quando necessÃ¡rio
- Prefira Server Components quando possÃ­vel
- Use TypeScript interfaces para props
- Implemente error boundaries quando apropriado

**Template de Componente:**

```typescript
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { mySchema } from "@/lib/validators/my.schema";
import { toast } from "sonner";

interface MyComponentProps {
  // Define props aqui
}

export default function MyComponent({}: MyComponentProps) {
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(mySchema),
  });

  const onSubmit = async (data: any) => {
    setIsLoading(true);
    try {
      // LÃ³gica do submit
      toast.success("Sucesso!");
    } catch (error) {
      toast.error("Erro!");
    } finally {
      setIsLoading(false);
    }
  };

  return <form onSubmit={handleSubmit(onSubmit)}>{/* JSX aqui */}</form>;
}
```

### 5. Gerenciamento de Estado

#### Zustand (Estado Global):

- Use para estado que precisa ser compartilhado globalmente
- Stores em `src/lib/stores/`
- Use persist middleware quando apropriado

#### TanStack Query (Server State):

- Use para todas as operaÃ§Ãµes de dados do servidor
- Hooks customizados em `src/lib/query/hooks/`
- Query keys centralizadas em `src/lib/query/keys.ts`

**Exemplo de Query Hook:**

```typescript
import { useQuery } from "@tanstack/react-query";
import { queryKeys } from "@/lib/query/keys";

export function useUsers() {
  return useQuery({
    queryKey: queryKeys.users.all,
    queryFn: () => fetch("/api/users").then((res) => res.json()),
  });
}
```

### 6. FormulÃ¡rios com React Hook Form + Zod

- Sempre use Zod para validaÃ§Ã£o
- Schemas em `src/lib/validators/`
- Use `zodResolver` para integraÃ§Ã£o
- Trate estados de loading adequadamente

### 7. EstilizaÃ§Ã£o com Tailwind CSS

- Use classes do Tailwind CSS
- Componentes customizados com `cn()` utility
- Mantenha design system consistente com shadcn/ui
- Use CSS Variables para temas (jÃ¡ configurado)

### 8. Banco de Dados com Prisma

- Schema em `prisma/schema.prisma`
- Migrations automÃ¡ticas
- Cliente gerado em `src/generated/prisma/`
- Sempre use transaÃ§Ãµes para operaÃ§Ãµes complexas

**Exemplo de Service com Prisma:**

```typescript
import prisma from "@/lib/prisma/client";

export const userService = {
  async create(data: CreateUserData) {
    return await prisma.usuario.create({
      data: {
        ...data,
        senha: await hashPassword(data.senha),
      },
    });
  },

  async findById(id: string) {
    return await prisma.usuario.findUnique({
      where: { id },
      include: {
        aluno: true,
        professor: true,
      },
    });
  },
};
```

## ğŸ”’ SeguranÃ§a

1. **Sempre valide entradas** com Zod schemas
2. **Verificar autenticaÃ§Ã£o** antes de operaÃ§Ãµes sensÃ­veis
3. **Hash passwords** com bcryptjs
4. **Sanitizar dados** antes de salvar no banco
5. **Usar tipos TypeScript** para type safety
6. **Implementar rate limiting** em APIs pÃºblicas

## ğŸ¨ UI/UX Guidelines

1. **Use componentes shadcn/ui** como base
2. **Mantenha consistÃªncia** no design system
3. **Implemente loading states** em todas as operaÃ§Ãµes assÃ­ncronas
4. **Use toast notifications** para feedback do usuÃ¡rio
5. **Responsividade** mobile-first
6. **Acessibilidade** com atributos ARIA

## ğŸ§ª Qualidade de CÃ³digo

1. **TypeScript strict mode** habilitado
2. **ESLint + Prettier** para formataÃ§Ã£o
3. **Nomes descritivos** para variÃ¡veis e funÃ§Ãµes
4. **ComentÃ¡rios em portuguÃªs** para lÃ³gica complexa
5. **Logs em inglÃªs** para debugging
6. **Trate todos os erros** adequadamente

## ğŸ“ ConvenÃ§Ãµes de Nomenclatura

- **Arquivos:** kebab-case (`user-profile.tsx`)
- **Componentes:** PascalCase (`UserProfile`)
- **VariÃ¡veis/FunÃ§Ãµes:** camelCase (`getUserData`)
- **Constantes:** UPPER_CASE (`API_ENDPOINTS`)
- **Types/Interfaces:** PascalCase (`UserData`)

## ğŸš« Evite

1. âŒ Acessar Prisma diretamente das API routes
2. âŒ LÃ³gica de negÃ³cio em componentes React
3. âŒ Hooks do React em Server Components
4. âŒ MutaÃ§Ã£o direta de props
5. âŒ Inline styles (use Tailwind)
6. âŒ Any types (use TypeScript adequadamente)
7. âŒ Console.log em produÃ§Ã£o

## âœ… Sempre FaÃ§a

1. âœ… Use a camada de serviÃ§o para lÃ³gica de negÃ³cio
2. âœ… Valide todas as entradas de API
3. âœ… Implemente loading e error states
4. âœ… Use TypeScript para type safety
5. âœ… Trate erros graciosamente
6. âœ… Mantenha componentes pequenos e focados
7. âœ… Use Server Components quando possÃ­vel
8. âœ… Implemente feedback visual para aÃ§Ãµes do usuÃ¡rio

---

**Lembre-se:** Este projeto Ã© para uma academia de Taekwondo, mantenha o contexto do domÃ­nio em mente ao desenvolver features relacionadas a alunos, professores, graduaÃ§Ãµes, pagamentos e eventos.
