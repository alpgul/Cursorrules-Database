# Cursor Rules - Ebener TKD Project

Regras de desenvolvimento para o projeto **Ebener TKD**, uma aplicação full-stack para gerenciamento de academia de Taekwondo.

## 🚀 Stack Tecnológico

- **Framework:** Next.js 15 (App Router)
- **Linguagem:** TypeScript
- **Banco de Dados:** PostgreSQL com Prisma ORM
- **Autenticação:** NextAuth.js 4 com Credentials Provider
- **UI:** Tailwind CSS + shadcn/ui + Radix UI
- **Estado:** Zustand (client) + TanStack Query (server state)
- **Formulários:** React Hook Form + Zod validation
- **Animações:** Framer Motion
- **Ícones:** Lucide React
- **Notificações:** Sonner (toast)

## 📁 Estrutura do Projeto

```
src/
├── app/                      # App Router do Next.js
│   ├── (auth)/              # Grupo de rotas de autenticação
│   ├── (dashboard)/         # Grupo de rotas do dashboard
│   ├── (pages)/             # Grupo de rotas públicas
│   └── api/                 # API Routes
├── components/              # Componentes React
│   ├── ui/                  # shadcn/ui components
│   ├── auth/                # Componentes de autenticação
│   ├── dashboard/           # Componentes do dashboard
│   └── [feature]/           # Componentes por feature
├── lib/                     # Utilitários e configurações
│   ├── auth/                # Configuração do NextAuth
│   ├── prisma/              # Cliente Prisma
│   ├── services/            # Camada de serviço (business logic)
│   ├── validators/          # Schemas Zod
│   ├── stores/              # Stores Zustand
│   ├── query/               # TanStack Query config
│   └── providers/           # React Providers
```

## 🏗️ Arquitetura e Padrões

### 1. Camada de Serviço (Business Logic)

- **NUNCA acesse Prisma diretamente das API routes**
- Toda lógica de negócio deve estar em `src/lib/services/`
- Cada service deve focar em um único recurso do schema
- Use sempre a instância singleton do Prisma em `src/lib/prisma/client.ts`

**Exemplo correto:**

```typescript
// ❌ Não faça isso na API route
const users = await prisma.user.findMany();

// ✅ Faça isso
const users = await userService.getAllUsers();
```

### 2. API Routes (Next.js App Router)

- Sempre valide entrada com Zod schemas
- Sempre verifique autenticação/autorização primeiro
- Use funções da camada de serviço para lógica de negócio
- Trate erros adequadamente com status codes apropriados

**Template de API Route:**

```typescript
import { NextResponse } from "next/server";
import { getAuthenticatedUser } from "@/lib/auth/session";
import { createUserSchema } from "@/lib/validators/user.schema";
import { userService } from "@/lib/services/user.service";

export async function POST(req: Request) {
  try {
    // 1. Verificar autenticação
    const user = await getAuthenticatedUser();

    // 2. Validar entrada
    const body = await req.json();
    const validation = createUserSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        { errors: validation.error.flatten().fieldErrors },
        { status: 400 }
      );
    }

    // 3. Executar lógica de negócio
    const result = await userService.create(validation.data);

    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { message: "Internal server error" },
      { status: 500 }
    );
  }
}
```

### 3. Autenticação com NextAuth.js

- Configuração centralizada em `src/lib/auth/options.ts`
- Use `getAuthenticatedUser()` para verificar sessão nas API routes
- Proteja rotas de dashboard com middleware ou verificação no layout
- Tipos customizados para User e Session já estão configurados

### 4. Componentes React

#### Estrutura de Componentes:

- **UI Components:** `src/components/ui/` (shadcn/ui)
- **Feature Components:** `src/components/[feature]/`
- **Layout Components:** Layouts específicos por grupo de rotas

#### Padrões de Componentes:

- Use `"use client"` apenas quando necessário
- Prefira Server Components quando possível
- Use TypeScript interfaces para props
- Implemente error boundaries quando apropriado

**Template de Componente:**

```typescript
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { mySchema } from "@/lib/validators/my.schema";
import { toast } from "sonner";

interface MyComponentProps {
  // Define props aqui
}

export default function MyComponent({}: MyComponentProps) {
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(mySchema),
  });

  const onSubmit = async (data: any) => {
    setIsLoading(true);
    try {
      // Lógica do submit
      toast.success("Sucesso!");
    } catch (error) {
      toast.error("Erro!");
    } finally {
      setIsLoading(false);
    }
  };

  return <form onSubmit={handleSubmit(onSubmit)}>{/* JSX aqui */}</form>;
}
```

### 5. Gerenciamento de Estado

#### Zustand (Estado Global):

- Use para estado que precisa ser compartilhado globalmente
- Stores em `src/lib/stores/`
- Use persist middleware quando apropriado

#### TanStack Query (Server State):

- Use para todas as operações de dados do servidor
- Hooks customizados em `src/lib/query/hooks/`
- Query keys centralizadas em `src/lib/query/keys.ts`

**Exemplo de Query Hook:**

```typescript
import { useQuery } from "@tanstack/react-query";
import { queryKeys } from "@/lib/query/keys";

export function useUsers() {
  return useQuery({
    queryKey: queryKeys.users.all,
    queryFn: () => fetch("/api/users").then((res) => res.json()),
  });
}
```

### 6. Formulários com React Hook Form + Zod

- Sempre use Zod para validação
- Schemas em `src/lib/validators/`
- Use `zodResolver` para integração
- Trate estados de loading adequadamente

### 7. Estilização com Tailwind CSS

- Use classes do Tailwind CSS
- Componentes customizados com `cn()` utility
- Mantenha design system consistente com shadcn/ui
- Use CSS Variables para temas (já configurado)

### 8. Banco de Dados com Prisma

- Schema em `prisma/schema.prisma`
- Migrations automáticas
- Cliente gerado em `src/generated/prisma/`
- Sempre use transações para operações complexas

**Exemplo de Service com Prisma:**

```typescript
import prisma from "@/lib/prisma/client";

export const userService = {
  async create(data: CreateUserData) {
    return await prisma.usuario.create({
      data: {
        ...data,
        senha: await hashPassword(data.senha),
      },
    });
  },

  async findById(id: string) {
    return await prisma.usuario.findUnique({
      where: { id },
      include: {
        aluno: true,
        professor: true,
      },
    });
  },
};
```

## 🔒 Segurança

1. **Sempre valide entradas** com Zod schemas
2. **Verificar autenticação** antes de operações sensíveis
3. **Hash passwords** com bcryptjs
4. **Sanitizar dados** antes de salvar no banco
5. **Usar tipos TypeScript** para type safety
6. **Implementar rate limiting** em APIs públicas

## 🎨 UI/UX Guidelines

1. **Use componentes shadcn/ui** como base
2. **Mantenha consistência** no design system
3. **Implemente loading states** em todas as operações assíncronas
4. **Use toast notifications** para feedback do usuário
5. **Responsividade** mobile-first
6. **Acessibilidade** com atributos ARIA

## 🧪 Qualidade de Código

1. **TypeScript strict mode** habilitado
2. **ESLint + Prettier** para formatação
3. **Nomes descritivos** para variáveis e funções
4. **Comentários em português** para lógica complexa
5. **Logs em inglês** para debugging
6. **Trate todos os erros** adequadamente

## 📝 Convenções de Nomenclatura

- **Arquivos:** kebab-case (`user-profile.tsx`)
- **Componentes:** PascalCase (`UserProfile`)
- **Variáveis/Funções:** camelCase (`getUserData`)
- **Constantes:** UPPER_CASE (`API_ENDPOINTS`)
- **Types/Interfaces:** PascalCase (`UserData`)

## 🚫 Evite

1. ❌ Acessar Prisma diretamente das API routes
2. ❌ Lógica de negócio em componentes React
3. ❌ Hooks do React em Server Components
4. ❌ Mutação direta de props
5. ❌ Inline styles (use Tailwind)
6. ❌ Any types (use TypeScript adequadamente)
7. ❌ Console.log em produção

## ✅ Sempre Faça

1. ✅ Use a camada de serviço para lógica de negócio
2. ✅ Valide todas as entradas de API
3. ✅ Implemente loading e error states
4. ✅ Use TypeScript para type safety
5. ✅ Trate erros graciosamente
6. ✅ Mantenha componentes pequenos e focados
7. ✅ Use Server Components quando possível
8. ✅ Implemente feedback visual para ações do usuário

---

**Lembre-se:** Este projeto é para uma academia de Taekwondo, mantenha o contexto do domínio em mente ao desenvolver features relacionadas a alunos, professores, graduações, pagamentos e eventos.
