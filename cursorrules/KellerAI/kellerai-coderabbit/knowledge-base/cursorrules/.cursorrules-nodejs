# KellerAI Node.js and API Development Standards
# .cursorrules for Node.js/Backend Projects
# Version: 1.0
# Last Updated: 2025-10-14

## Project Context
This ruleset applies to KellerAI Node.js backend projects including REST APIs, GraphQL servers, microservices, and serverless functions with emphasis on security, performance, and reliability.

## API Framework Standards

### FastAPI-style Express with TypeScript
```typescript
import express, { Request, Response, NextFunction } from 'express';
import { z } from 'zod';

const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Request validation schema
const CreateUserSchema = z.object({
  body: z.object({
    name: z.string().min(2).max(100),
    email: z.string().email(),
    age: z.number().int().min(18),
    role: z.enum(['admin', 'user', 'guest']),
  }),
});

type CreateUserRequest = z.infer<typeof CreateUserSchema>['body'];

// Validation middleware
function validate<T extends z.ZodTypeAny>(schema: T) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          error: 'Validation failed',
          details: error.errors,
        });
      } else {
        next(error);
      }
    }
  };
}

// Route handler with proper typing
app.post(
  '/api/v1/users',
  validate(CreateUserSchema),
  async (req: Request<{}, {}, CreateUserRequest>, res: Response, next: NextFunction) => {
    try {
      const user = await userService.createUser(req.body);
      res.status(201).json({
        success: true,
        data: user,
      });
    } catch (error) {
      next(error);
    }
  }
);

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error('Request error:', {
    error: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });

  if (err instanceof ApiError) {
    res.status(err.statusCode).json({
      error: err.message,
      code: err.code,
    });
  } else {
    res.status(500).json({
      error: 'Internal server error',
    });
  }
});
```

## Request/Response Patterns

### Standardized Response Format
```typescript
// Response types
interface SuccessResponse<T> {
  success: true;
  data: T;
  metadata?: {
    timestamp: string;
    requestId: string;
  };
}

interface ErrorResponse {
  success: false;
  error: {
    message: string;
    code: string;
    details?: unknown;
  };
}

type ApiResponse<T> = SuccessResponse<T> | ErrorResponse;

// Helper functions
function successResponse<T>(data: T, requestId?: string): SuccessResponse<T> {
  return {
    success: true,
    data,
    metadata: {
      timestamp: new Date().toISOString(),
      requestId: requestId || generateRequestId(),
    },
  };
}

function errorResponse(
  message: string,
  code: string,
  details?: unknown
): ErrorResponse {
  return {
    success: false,
    error: {
      message,
      code,
      details,
    },
  };
}

// Usage in routes
app.get('/api/v1/users/:id', async (req, res, next) => {
  try {
    const user = await userService.getUser(req.params.id);
    res.json(successResponse(user, req.headers['x-request-id'] as string));
  } catch (error) {
    if (error instanceof NotFoundError) {
      res.status(404).json(errorResponse(error.message, 'NOT_FOUND'));
    } else {
      next(error);
    }
  }
});
```

### Pagination Standard
```typescript
interface PaginationParams {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    currentPage: number;
    totalPages: number;
    totalItems: number;
    itemsPerPage: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
}

function parsePaginationParams(query: any): PaginationParams {
  return {
    page: Math.max(1, parseInt(query.page) || 1),
    limit: Math.min(100, Math.max(1, parseInt(query.limit) || 20)),
    sortBy: query.sortBy,
    sortOrder: query.sortOrder === 'desc' ? 'desc' : 'asc',
  };
}

async function getPaginatedUsers(
  params: PaginationParams
): Promise<PaginatedResponse<User>> {
  const offset = (params.page - 1) * params.limit;

  const [items, totalItems] = await Promise.all([
    db.users.find({
      skip: offset,
      take: params.limit,
      orderBy: params.sortBy ? { [params.sortBy]: params.sortOrder } : undefined,
    }),
    db.users.count(),
  ]);

  const totalPages = Math.ceil(totalItems / params.limit);

  return {
    items,
    pagination: {
      currentPage: params.page,
      totalPages,
      totalItems,
      itemsPerPage: params.limit,
      hasNextPage: params.page < totalPages,
      hasPreviousPage: params.page > 1,
    },
  };
}
```

## Authentication and Authorization

### JWT Authentication Middleware
```typescript
import jwt from 'jsonwebtoken';

interface JwtPayload {
  userId: string;
  email: string;
  role: string;
}

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: JwtPayload;
    }
  }
}

function authenticateToken(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers['authorization'];
  const token = authHeader?.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json(errorResponse('No token provided', 'UNAUTHORIZED'));
  }

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;
    req.user = payload;
    next();
  } catch (error) {
    return res.status(403).json(errorResponse('Invalid token', 'FORBIDDEN'));
  }
}

// Role-based authorization
function authorize(...allowedRoles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json(errorResponse('Not authenticated', 'UNAUTHORIZED'));
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json(
        errorResponse('Insufficient permissions', 'FORBIDDEN')
      );
    }

    next();
  };
}

// Usage
app.get('/api/v1/admin/users', authenticateToken, authorize('admin'), async (req, res) => {
  // Only admins can access this endpoint
});

app.get('/api/v1/users/me', authenticateToken, async (req, res) => {
  // Any authenticated user can access this endpoint
  const user = await userService.getUser(req.user!.userId);
  res.json(successResponse(user));
});
```

### API Key Authentication
```typescript
async function validateApiKey(req: Request, res: Response, next: NextFunction) {
  const apiKey = req.headers['x-api-key'] as string;

  if (!apiKey) {
    return res.status(401).json(errorResponse('API key required', 'UNAUTHORIZED'));
  }

  try {
    const keyData = await apiKeyService.validate(apiKey);

    if (!keyData.active) {
      return res.status(403).json(errorResponse('API key inactive', 'FORBIDDEN'));
    }

    // Rate limiting per API key
    const rateLimitOk = await checkRateLimit(keyData.id);
    if (!rateLimitOk) {
      return res.status(429).json(
        errorResponse('Rate limit exceeded', 'RATE_LIMIT_EXCEEDED')
      );
    }

    req.apiKey = keyData;
    next();
  } catch (error) {
    return res.status(401).json(errorResponse('Invalid API key', 'UNAUTHORIZED'));
  }
}
```

## Rate Limiting

### Express Rate Limit Configuration
```typescript
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// General API rate limit
const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rate-limit:',
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true, // Return rate limit info in headers
  legacyHeaders: false,
  message: 'Too many requests from this IP, please try again later.',
  handler: (req, res) => {
    res.status(429).json(
      errorResponse('Rate limit exceeded', 'RATE_LIMIT_EXCEEDED')
    );
  },
});

// Strict rate limit for sensitive endpoints
const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5, // 5 requests per hour
  skipSuccessfulRequests: true, // Don't count successful requests
  message: 'Too many authentication attempts, please try again later.',
});

// Per-user rate limiting
const createUserLimiter = (userId: string) =>
  rateLimit({
    windowMs: 60 * 1000, // 1 minute
    max: 10,
    keyGenerator: () => userId,
  });

// Apply to routes
app.use('/api/', apiLimiter);
app.post('/api/v1/auth/login', authLimiter, loginHandler);
```

## Database Operations

### Prisma ORM Best Practices
```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

// Transaction management
async function transferCredits(
  fromUserId: string,
  toUserId: string,
  amount: number
): Promise<void> {
  await prisma.$transaction(async (tx) => {
    // Deduct credits from sender
    const sender = await tx.user.update({
      where: { id: fromUserId },
      data: { credits: { decrement: amount } },
    });

    if (sender.credits < 0) {
      throw new Error('Insufficient credits');
    }

    // Add credits to receiver
    await tx.user.update({
      where: { id: toUserId },
      data: { credits: { increment: amount } },
    });

    // Create transaction record
    await tx.transaction.create({
      data: {
        fromUserId,
        toUserId,
        amount,
        type: 'TRANSFER',
        status: 'COMPLETED',
      },
    });
  });
}

// Efficient queries with select and include
async function getUserWithPosts(userId: string) {
  return prisma.user.findUnique({
    where: { id: userId },
    select: {
      id: true,
      name: true,
      email: true,
      posts: {
        select: {
          id: true,
          title: true,
          publishedAt: true,
        },
        where: {
          published: true,
        },
        orderBy: {
          publishedAt: 'desc',
        },
        take: 10,
      },
      _count: {
        select: {
          posts: true,
          comments: true,
        },
      },
    },
  });
}

// Batch operations
async function createManyUsers(users: CreateUserInput[]): Promise<void> {
  await prisma.user.createMany({
    data: users,
    skipDuplicates: true, // Skip duplicates instead of failing
  });
}

// Soft delete pattern
async function softDeleteUser(userId: string): Promise<void> {
  await prisma.user.update({
    where: { id: userId },
    data: {
      deletedAt: new Date(),
      email: `deleted_${userId}@deleted.com`, // Free up unique constraint
    },
  });
}
```

### Query Optimization
```typescript
// ❌ BAD - N+1 query problem
async function getUsersWithPosts() {
  const users = await prisma.user.findMany();

  for (const user of users) {
    user.posts = await prisma.post.findMany({
      where: { userId: user.id },
    });
  }

  return users;
}

// ✅ GOOD - Single query with include
async function getUsersWithPosts() {
  return prisma.user.findMany({
    include: {
      posts: true,
    },
  });
}

// ✅ GOOD - DataLoader for GraphQL
import DataLoader from 'dataloader';

const userLoader = new DataLoader<string, User>(async (userIds) => {
  const users = await prisma.user.findMany({
    where: {
      id: { in: [...userIds] },
    },
  });

  const userMap = new Map(users.map(user => [user.id, user]));
  return userIds.map(id => userMap.get(id)!);
});
```

## Error Handling

### Custom Error Classes
```typescript
export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public code: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends ApiError {
  constructor(message: string, details?: unknown) {
    super(400, 'VALIDATION_ERROR', message, details);
  }
}

export class NotFoundError extends ApiError {
  constructor(resource: string, id: string) {
    super(404, 'NOT_FOUND', `${resource} not found: ${id}`);
  }
}

export class UnauthorizedError extends ApiError {
  constructor(message: string = 'Unauthorized') {
    super(401, 'UNAUTHORIZED', message);
  }
}

export class ForbiddenError extends ApiError {
  constructor(message: string = 'Forbidden') {
    super(403, 'FORBIDDEN', message);
  }
}

export class ConflictError extends ApiError {
  constructor(message: string) {
    super(409, 'CONFLICT', message);
  }
}

export class RateLimitError extends ApiError {
  constructor() {
    super(429, 'RATE_LIMIT_EXCEEDED', 'Rate limit exceeded');
  }
}
```

### Global Error Handler
```typescript
import { Request, Response, NextFunction } from 'express';

function errorHandler(err: Error, req: Request, res: Response, next: NextFunction) {
  // Log error with context
  logger.error('Request error', {
    error: err.message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    path: req.path,
    method: req.method,
    body: req.body,
    params: req.params,
    query: req.query,
    user: req.user?.userId,
  });

  // Send appropriate response
  if (err instanceof ApiError) {
    res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.message,
        code: err.code,
        details: process.env.NODE_ENV === 'development' ? err.details : undefined,
      },
    });
  } else if (err instanceof z.ZodError) {
    res.status(400).json({
      success: false,
      error: {
        message: 'Validation failed',
        code: 'VALIDATION_ERROR',
        details: err.errors,
      },
    });
  } else {
    // Unknown error - don't leak details
    res.status(500).json({
      success: false,
      error: {
        message: 'Internal server error',
        code: 'INTERNAL_ERROR',
      },
    });
  }
}

// Async error wrapper
function asyncHandler<T>(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<T>
) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// Usage
app.get('/api/v1/users/:id', asyncHandler(async (req, res) => {
  const user = await userService.getUser(req.params.id);
  res.json(successResponse(user));
}));
```

## Logging

### Structured Logging with Winston
```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'api',
    environment: process.env.NODE_ENV,
  },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
    }),
    new winston.transports.File({
      filename: 'logs/combined.log',
    }),
  ],
});

// Request logging middleware
function requestLogger(req: Request, res: Response, next: NextFunction) {
  const startTime = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - startTime;

    logger.info('Request completed', {
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      duration,
      userAgent: req.headers['user-agent'],
      ip: req.ip,
      userId: req.user?.userId,
    });
  });

  next();
}

// Contextual logging
function createUserLogger(userId: string) {
  return logger.child({ userId });
}

// Usage
const userLogger = createUserLogger('user-123');
userLogger.info('User action', { action: 'login' });
```

## Background Jobs and Queues

### Bull Queue for Job Processing
```typescript
import Queue from 'bull';
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

interface EmailJobData {
  to: string;
  subject: string;
  body: string;
  userId: string;
}

const emailQueue = new Queue<EmailJobData>('email', {
  redis: {
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT || '6379'),
  },
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000,
    },
    removeOnComplete: true,
    removeOnFail: false,
  },
});

// Job processor
emailQueue.process(async (job) => {
  logger.info('Processing email job', { jobId: job.id, data: job.data });

  try {
    await sendEmail({
      to: job.data.to,
      subject: job.data.subject,
      body: job.data.body,
    });

    logger.info('Email sent successfully', { jobId: job.id });
    return { success: true };
  } catch (error) {
    logger.error('Email sending failed', {
      jobId: job.id,
      error: error.message,
    });
    throw error; // Will trigger retry
  }
});

// Add job to queue
async function queueEmail(data: EmailJobData) {
  const job = await emailQueue.add(data, {
    priority: data.userId === 'admin' ? 1 : 10, // Higher priority for admin
    delay: 0,
  });

  logger.info('Email queued', { jobId: job.id });
  return job.id;
}

// Schedule recurring job
emailQueue.add(
  { type: 'daily-digest' },
  {
    repeat: {
      cron: '0 9 * * *', // Every day at 9 AM
    },
  }
);
```

## Testing

### Unit Testing with Jest
```typescript
import { userService } from './user-service';
import { prismaMock } from '../test/prisma-mock';

describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user successfully', async () => {
      // Arrange
      const input = {
        name: 'Alice',
        email: 'alice@example.com',
        age: 30,
      };
      const expectedUser = { id: '1', ...input };

      prismaMock.user.create.mockResolvedValue(expectedUser);

      // Act
      const result = await userService.createUser(input);

      // Assert
      expect(result).toEqual(expectedUser);
      expect(prismaMock.user.create).toHaveBeenCalledWith({
        data: input,
      });
    });

    it('should throw ValidationError for invalid email', async () => {
      // Arrange
      const input = {
        name: 'Bob',
        email: 'invalid-email',
        age: 25,
      };

      // Act & Assert
      await expect(userService.createUser(input)).rejects.toThrow(ValidationError);
    });

    it('should throw ConflictError for duplicate email', async () => {
      // Arrange
      const input = {
        name: 'Charlie',
        email: 'existing@example.com',
        age: 28,
      };

      prismaMock.user.create.mockRejectedValue({
        code: 'P2002', // Prisma unique constraint error
        meta: { target: ['email'] },
      });

      // Act & Assert
      await expect(userService.createUser(input)).rejects.toThrow(ConflictError);
    });
  });
});
```

### Integration Testing
```typescript
import request from 'supertest';
import { app } from '../app';
import { prisma } from '../prisma';

describe('POST /api/v1/users', () => {
  beforeEach(async () => {
    await prisma.user.deleteMany(); // Clean database
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  it('should create a new user', async () => {
    // Arrange
    const userData = {
      name: 'Test User',
      email: 'test@example.com',
      age: 30,
      role: 'user',
    };

    // Act
    const response = await request(app)
      .post('/api/v1/users')
      .send(userData)
      .set('Content-Type', 'application/json')
      .expect(201);

    // Assert
    expect(response.body).toMatchObject({
      success: true,
      data: {
        name: userData.name,
        email: userData.email,
      },
    });
    expect(response.body.data.id).toBeDefined();

    // Verify in database
    const userInDb = await prisma.user.findUnique({
      where: { id: response.body.data.id },
    });
    expect(userInDb).toBeTruthy();
    expect(userInDb?.email).toBe(userData.email);
  });

  it('should return 400 for invalid input', async () => {
    // Arrange
    const invalidData = {
      name: 'A', // Too short
      email: 'invalid-email',
      age: 15, // Too young
    };

    // Act
    const response = await request(app)
      .post('/api/v1/users')
      .send(invalidData)
      .expect(400);

    // Assert
    expect(response.body.success).toBe(false);
    expect(response.body.error.code).toBe('VALIDATION_ERROR');
  });

  it('should require authentication', async () => {
    // Act
    await request(app)
      .get('/api/v1/users/me')
      .expect(401);
  });

  it('should accept valid JWT token', async () => {
    // Arrange
    const token = generateTestToken({ userId: 'test-user' });

    // Act
    await request(app)
      .get('/api/v1/users/me')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);
  });
});
```

## Security Best Practices

### Input Sanitization
```typescript
import DOMPurify from 'isomorphic-dompurify';
import validator from 'validator';

function sanitizeInput<T extends Record<string, any>>(input: T): T {
  const sanitized = { ...input };

  for (const [key, value] of Object.entries(sanitized)) {
    if (typeof value === 'string') {
      // Remove potential XSS
      sanitized[key] = DOMPurify.sanitize(value);
      // Escape HTML
      sanitized[key] = validator.escape(sanitized[key]);
    }
  }

  return sanitized;
}
```

### SQL Injection Prevention
```typescript
// ✅ GOOD - Using Prisma (parameterized queries)
await prisma.user.findMany({
  where: {
    email: userEmail, // Automatically parameterized
  },
});

// ❌ BAD - Raw SQL with string interpolation
await prisma.$queryRaw`SELECT * FROM users WHERE email = ${userEmail}`; // Vulnerable

// ✅ GOOD - Raw SQL with proper parameterization
await prisma.$queryRaw`SELECT * FROM users WHERE email = ${userEmail}`; // Actually safe with Prisma
```

### CORS Configuration
```typescript
import cors from 'cors';

const corsOptions: cors.CorsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];

    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400, // 24 hours
};

app.use(cors(corsOptions));
```

### Helmet for Security Headers
```typescript
import helmet from 'helmet';

app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", 'data:', 'https:'],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  })
);
```

## Code Review Checklist

Before submitting Node.js/API code for review, verify:

- [ ] All routes have input validation (Zod/Joi)
- [ ] Authentication/authorization implemented correctly
- [ ] Rate limiting configured for sensitive endpoints
- [ ] Error handling with proper status codes
- [ ] Logging for important operations and errors
- [ ] Database queries optimized (no N+1 queries)
- [ ] Transactions used for multi-step operations
- [ ] Security headers configured (Helmet)
- [ ] CORS properly configured
- [ ] No hardcoded secrets or API keys
- [ ] Tests cover happy path and error cases
- [ ] API documentation updated (OpenAPI/Swagger)
- [ ] Proper cleanup of resources (connections, timers)
- [ ] Background jobs for long-running operations

---

**Last Updated**: 2025-10-14
**Maintainer**: KellerAI Engineering Team
**Questions**: Contact the platform team for clarifications
