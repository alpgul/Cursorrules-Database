# è°ƒè¯•å’Œé—®é¢˜è§£å†³æŒ‡å—

## è°ƒè¯•å·¥å…·é…ç½®

### Vue DevTools é…ç½®
```typescript
// main.ts - å¼€å‘çŽ¯å¢ƒå¯ç”¨Vue DevTools
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

// å¼€å‘çŽ¯å¢ƒé…ç½®
if (import.meta.env.DEV) {
  // å¯ç”¨Vue DevTools
  app.config.devtools = true
  
  // å¯ç”¨æ€§èƒ½è¿½è¸ª
  app.config.performance = true
  
  // å…¨å±€é”™è¯¯å¤„ç†
  app.config.errorHandler = (err, vm, info) => {
    console.error('Vue Error:', err)
    console.error('Component:', vm)
    console.error('Error Info:', info)
  }
  
  // å…¨å±€è­¦å‘Šå¤„ç†
  app.config.warnHandler = (msg, vm, trace) => {
    console.warn('Vue Warning:', msg)
    console.warn('Component:', vm)
    console.warn('Trace:', trace)
  }
}

app.mount('#app')
```

### æµè§ˆå™¨è°ƒè¯•é…ç½®
```typescript
// utils/debug.ts
export class DebugHelper {
  private static instance: DebugHelper
  private debugMode: boolean
  
  constructor() {
    this.debugMode = import.meta.env.DEV || localStorage.getItem('debug') === 'true'
  }
  
  static getInstance(): DebugHelper {
    if (!DebugHelper.instance) {
      DebugHelper.instance = new DebugHelper()
    }
    return DebugHelper.instance
  }
  
  /**
   * å¯ç”¨è°ƒè¯•æ¨¡å¼
   */
  enable(): void {
    this.debugMode = true
    localStorage.setItem('debug', 'true')
    console.log('ðŸ› è°ƒè¯•æ¨¡å¼å·²å¯ç”¨')
  }
  
  /**
   * ç¦ç”¨è°ƒè¯•æ¨¡å¼
   */
  disable(): void {
    this.debugMode = false
    localStorage.removeItem('debug')
    console.log('ðŸ› è°ƒè¯•æ¨¡å¼å·²ç¦ç”¨')
  }
  
  /**
   * è°ƒè¯•æ—¥å¿—
   */
  log(message: string, ...args: any[]): void {
    if (this.debugMode) {
      console.log(`ðŸ› [DEBUG] ${message}`, ...args)
    }
  }
  
  /**
   * è°ƒè¯•ä¿¡æ¯
   */
  info(message: string, ...args: any[]): void {
    if (this.debugMode) {
      console.info(`â„¹ï¸ [INFO] ${message}`, ...args)
    }
  }
  
  /**
   * è°ƒè¯•è­¦å‘Š
   */
  warn(message: string, ...args: any[]): void {
    if (this.debugMode) {
      console.warn(`âš ï¸ [WARN] ${message}`, ...args)
    }
  }
  
  /**
   * è°ƒè¯•é”™è¯¯
   */
  error(message: string, ...args: any[]): void {
    if (this.debugMode) {
      console.error(`âŒ [ERROR] ${message}`, ...args)
    }
  }
  
  /**
   * æ€§èƒ½æµ‹é‡
   */
  time(label: string): void {
    if (this.debugMode) {
      console.time(`â±ï¸ [PERF] ${label}`)
    }
  }
  
  timeEnd(label: string): void {
    if (this.debugMode) {
      console.timeEnd(`â±ï¸ [PERF] ${label}`)
    }
  }
  
  /**
   * è¿½è¸ªå‡½æ•°è°ƒç”¨
   */
  trace(message?: string): void {
    if (this.debugMode) {
      console.trace(`ðŸ“ [TRACE] ${message || ''}`)
    }
  }
  
  /**
   * ç»„ä»¶çŠ¶æ€å¿«ç…§
   */
  snapshot(label: string, data: any): void {
    if (this.debugMode) {
      console.group(`ðŸ“¸ [SNAPSHOT] ${label}`)
      console.log(JSON.parse(JSON.stringify(data)))
      console.groupEnd()
    }
  }
}

// å…¨å±€è°ƒè¯•å®žä¾‹
export const debug = DebugHelper.getInstance()

// åœ¨windowä¸Šæš´éœ²è°ƒè¯•å·¥å…·ï¼ˆä»…å¼€å‘çŽ¯å¢ƒï¼‰
if (import.meta.env.DEV) {
  (window as any).debug = debug
}
```

## å¸¸è§é—®é¢˜è¯Šæ–­

### ç³»ç»Ÿæ€§Bugåˆ†æžæ¨¡å¼
```typescript
// composables/useBugAnalysis.ts
export function useBugAnalysis() {
  /**
   * ç³»ç»Ÿæ€§åˆ†æžbugäº§ç”Ÿçš„æ ¹æœ¬åŽŸå› 
   */
  const analyzeRootCause = (error: Error, context: any) => {
    const analysis = {
      timestamp: new Date().toISOString(),
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      context,
      environment: {
        userAgent: navigator.userAgent,
        url: window.location.href,
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        memory: (performance as any).memory || null
      },
      hypotheses: [] as string[],
      solutions: [] as string[]
    }
    
    // åˆ†æžå¯èƒ½çš„åŽŸå› 
    if (error.message.includes('undefined')) {
      analysis.hypotheses.push('å˜é‡æœªå®šä¹‰æˆ–å±žæ€§ä¸å­˜åœ¨')
      analysis.solutions.push('æ£€æŸ¥å˜é‡åˆå§‹åŒ–å’Œå¯¹è±¡å±žæ€§')
    }
    
    if (error.message.includes('network')) {
      analysis.hypotheses.push('ç½‘ç»œè¿žæŽ¥é—®é¢˜')
      analysis.solutions.push('æ£€æŸ¥APIç«¯ç‚¹å’Œç½‘ç»œçŠ¶æ€')
    }
    
    if (error.stack?.includes('reactive')) {
      analysis.hypotheses.push('Vueå“åº”å¼æ•°æ®é—®é¢˜')
      analysis.solutions.push('æ£€æŸ¥å“åº”å¼æ•°æ®çš„æ­£ç¡®ä½¿ç”¨')
    }
    
    return analysis
  }
  
  /**
   * æä¾›ä¸‰ç§ä¸åŒçš„è§£å†³æ–¹æ¡ˆ
   */
  const provideSolutions = (errorType: string) => {
    const solutions = {
      'undefined_error': [
        {
          title: 'é˜²å¾¡æ€§ç¼–ç¨‹',
          description: 'ä½¿ç”¨å¯é€‰é“¾æ“ä½œç¬¦å’Œé»˜è®¤å€¼',
          code: 'const value = data?.user?.name ?? "é»˜è®¤å€¼"',
          pros: ['å®‰å…¨æ€§é«˜', 'ä»£ç ç®€æ´'],
          cons: ['å¯èƒ½éšè—çœŸæ­£çš„é—®é¢˜']
        },
        {
          title: 'ç±»åž‹æ£€æŸ¥',
          description: 'åŠ å¼ºTypeScriptç±»åž‹æ£€æŸ¥',
          code: 'interface User { name: string }',
          pros: ['ç¼–è¯‘æœŸå‘çŽ°é—®é¢˜', 'ä»£ç æ›´å¥å£®'],
          cons: ['å¢žåŠ å¼€å‘å¤æ‚åº¦']
        },
        {
          title: 'è¿è¡Œæ—¶éªŒè¯',
          description: 'æ·»åŠ è¿è¡Œæ—¶æ•°æ®éªŒè¯',
          code: 'if (typeof data === "object" && data !== null)',
          pros: ['è¿è¡Œæ—¶å®‰å…¨', 'é”™è¯¯ä¿¡æ¯æ˜Žç¡®'],
          cons: ['æ€§èƒ½å¼€é”€']
        }
      ],
      'network_error': [
        {
          title: 'é‡è¯•æœºåˆ¶',
          description: 'å®žçŽ°æŒ‡æ•°é€€é¿é‡è¯•',
          code: 'await retry(apiCall, { retries: 3 })',
          pros: ['æé«˜æˆåŠŸçŽ‡', 'ç”¨æˆ·ä½“éªŒå¥½'],
          cons: ['å¯èƒ½å»¶é•¿å“åº”æ—¶é—´']
        },
        {
          title: 'ç¦»çº¿æ”¯æŒ',
          description: 'å®žçŽ°ç¦»çº¿ç¼“å­˜æœºåˆ¶',
          code: 'serviceWorker.cache(request)',
          pros: ['ç¦»çº¿å¯ç”¨', 'æ€§èƒ½æå‡'],
          cons: ['å®žçŽ°å¤æ‚', 'ç¼“å­˜ç®¡ç†']
        },
        {
          title: 'é™çº§æ–¹æ¡ˆ',
          description: 'æä¾›å¤‡ç”¨æ•°æ®æº',
          code: 'fallbackData || cachedData',
          pros: ['æœåŠ¡å¯ç”¨æ€§é«˜', 'ç”¨æˆ·ä½“éªŒè¿žç»­'],
          cons: ['æ•°æ®å¯èƒ½ä¸æ˜¯æœ€æ–°']
        }
      ]
    }
    
    return solutions[errorType] || []
  }
  
  return {
    analyzeRootCause,
    provideSolutions
  }
}
```

### Vueç›¸å…³é—®é¢˜è°ƒè¯•

#### å“åº”å¼æ•°æ®é—®é¢˜
```typescript
// è°ƒè¯•å“åº”å¼æ•°æ®
export function debugReactivity() {
  const { effect, trigger, track } = Vue
  
  // è¿½è¸ªå“åº”å¼ä¾èµ–
  const trackDependencies = (obj: any, path = '') => {
    if (typeof obj !== 'object' || obj === null) return
    
    Object.keys(obj).forEach(key => {
      const fullPath = path ? `${path}.${key}` : key
      console.log(`ðŸ“Œ Tracking: ${fullPath}`)
      
      if (typeof obj[key] === 'object') {
        trackDependencies(obj[key], fullPath)
      }
    })
  }
  
  // æ£€æŸ¥å“åº”å¼ä¸¢å¤±
  const checkReactivityLoss = (data: any) => {
    const issues = []
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯å“åº”å¼å¯¹è±¡
    if (!Vue.isReactive(data) && !Vue.isRef(data)) {
      issues.push('æ•°æ®ä¸æ˜¯å“åº”å¼çš„ï¼Œä½¿ç”¨reactive()æˆ–ref()åŒ…è£…')
    }
    
    // æ£€æŸ¥è§£æž„æ˜¯å¦ç ´åå“åº”å¼
    if (typeof data === 'object') {
      Object.keys(data).forEach(key => {
        if (typeof data[key] === 'object' && !Vue.isReactive(data[key])) {
          issues.push(`å±žæ€§ ${key} å¤±åŽ»å“åº”å¼ï¼Œé¿å…è§£æž„èµ‹å€¼`)
        }
      })
    }
    
    return issues
  }
  
  return {
    trackDependencies,
    checkReactivityLoss
  }
}
```

#### ç»„ä»¶é€šä¿¡é—®é¢˜
```typescript
// è°ƒè¯•ç»„ä»¶é€šä¿¡
export function debugComponentCommunication() {
  // Propsä¼ é€’è°ƒè¯•
  const debugProps = (props: any, expectedProps: string[]) => {
    const issues = []
    
    expectedProps.forEach(prop => {
      if (!(prop in props)) {
        issues.push(`ç¼ºå°‘å¿…è¦çš„prop: ${prop}`)
      } else if (props[prop] === undefined) {
        issues.push(`prop ${prop} çš„å€¼ä¸ºundefined`)
      }
    })
    
    // æ£€æŸ¥æ„å¤–çš„props
    Object.keys(props).forEach(prop => {
      if (!expectedProps.includes(prop)) {
        console.warn(`âš ï¸ æ„å¤–çš„prop: ${prop}`)
      }
    })
    
    return issues
  }
  
  // äº‹ä»¶å‘å°„è°ƒè¯•
  const debugEmits = (emitFn: Function, eventName: string, payload?: any) => {
    console.log(`ðŸ“¤ Emitting event: ${eventName}`, payload)
    try {
      emitFn(eventName, payload)
      console.log(`âœ… Event ${eventName} emitted successfully`)
    } catch (error) {
      console.error(`âŒ Failed to emit event ${eventName}:`, error)
    }
  }
  
  return {
    debugProps,
    debugEmits
  }
}
```

### æ€§èƒ½é—®é¢˜è¯Šæ–­

#### æ¸²æŸ“æ€§èƒ½åˆ†æž
```typescript
// composables/usePerformanceAnalysis.ts
export function usePerformanceAnalysis() {
  const measureRenderTime = (componentName: string) => {
    const startTime = performance.now()
    
    onMounted(() => {
      const endTime = performance.now()
      const renderTime = endTime - startTime
      
      if (renderTime > 100) {
        console.warn(`âš ï¸ ç»„ä»¶ ${componentName} æ¸²æŸ“æ—¶é—´è¿‡é•¿: ${renderTime.toFixed(2)}ms`)
      } else {
        console.log(`âœ… ç»„ä»¶ ${componentName} æ¸²æŸ“æ—¶é—´: ${renderTime.toFixed(2)}ms`)
      }
    })
  }
  
  const analyzeMemoryUsage = () => {
    if ('memory' in performance) {
      const memory = (performance as any).memory
      return {
        used: Math.round(memory.usedJSHeapSize / 1048576),
        total: Math.round(memory.totalJSHeapSize / 1048576),
        limit: Math.round(memory.jsHeapSizeLimit / 1048576)
      }
    }
    return null
  }
  
  const detectMemoryLeaks = () => {
    const samples = []
    let interval: number
    
    const start = () => {
      interval = setInterval(() => {
        const memory = analyzeMemoryUsage()
        if (memory) {
          samples.push({
            timestamp: Date.now(),
            memory: memory.used
          })
          
          // ä¿ç•™æœ€è¿‘10ä¸ªæ ·æœ¬
          if (samples.length > 10) {
            samples.shift()
          }
          
          // æ£€æŸ¥å†…å­˜æ˜¯å¦æŒç»­å¢žé•¿
          if (samples.length >= 5) {
            const trend = samples.slice(-5)
            const increasing = trend.every((sample, index) => 
              index === 0 || sample.memory >= trend[index - 1].memory
            )
            
            if (increasing) {
              console.warn('âš ï¸ æ£€æµ‹åˆ°å¯èƒ½çš„å†…å­˜æ³„æ¼')
            }
          }
        }
      }, 5000)
    }
    
    const stop = () => {
      if (interval) {
        clearInterval(interval)
      }
    }
    
    return { start, stop, samples }
  }
  
  return {
    measureRenderTime,
    analyzeMemoryUsage,
    detectMemoryLeaks
  }
}
```

### ç½‘ç»œè¯·æ±‚è°ƒè¯•

#### APIè°ƒè¯•å·¥å…·
```typescript
// utils/apiDebugger.ts
export class ApiDebugger {
  private requests: Map<string, any> = new Map()
  
  /**
   * æ‹¦æˆªè¯·æ±‚
   */
  interceptRequest(config: any) {
    const requestId = this.generateRequestId()
    const requestInfo = {
      id: requestId,
      url: config.url,
      method: config.method,
      headers: config.headers,
      data: config.data,
      timestamp: Date.now(),
      status: 'pending'
    }
    
    this.requests.set(requestId, requestInfo)
    
    console.group(`ðŸ“¤ API Request: ${config.method?.toUpperCase()} ${config.url}`)
    console.log('Request ID:', requestId)
    console.log('Headers:', config.headers)
    console.log('Data:', config.data)
    console.groupEnd()
    
    return { ...config, requestId }
  }
  
  /**
   * æ‹¦æˆªå“åº”
   */
  interceptResponse(response: any) {
    const requestId = response.config?.requestId
    if (requestId && this.requests.has(requestId)) {
      const requestInfo = this.requests.get(requestId)
      requestInfo.status = 'success'
      requestInfo.responseTime = Date.now() - requestInfo.timestamp
      requestInfo.response = {
        status: response.status,
        data: response.data,
        headers: response.headers
      }
      
      console.group(`ðŸ“¥ API Response: ${requestInfo.method?.toUpperCase()} ${requestInfo.url}`)
      console.log('Request ID:', requestId)
      console.log('Status:', response.status)
      console.log('Response Time:', `${requestInfo.responseTime}ms`)
      console.log('Data:', response.data)
      console.groupEnd()
      
      // æ€§èƒ½è­¦å‘Š
      if (requestInfo.responseTime > 3000) {
        console.warn(`âš ï¸ æ…¢è¯·æ±‚: ${requestInfo.url} (${requestInfo.responseTime}ms)`)
      }
    }
    
    return response
  }
  
  /**
   * æ‹¦æˆªé”™è¯¯
   */
  interceptError(error: any) {
    const requestId = error.config?.requestId
    if (requestId && this.requests.has(requestId)) {
      const requestInfo = this.requests.get(requestId)
      requestInfo.status = 'error'
      requestInfo.responseTime = Date.now() - requestInfo.timestamp
      requestInfo.error = {
        message: error.message,
        code: error.code,
        response: error.response
      }
      
      console.group(`âŒ API Error: ${requestInfo.method?.toUpperCase()} ${requestInfo.url}`)
      console.log('Request ID:', requestId)
      console.log('Error:', error.message)
      console.log('Response:', error.response)
      console.groupEnd()
    }
    
    return Promise.reject(error)
  }
  
  /**
   * èŽ·å–è¯·æ±‚ç»Ÿè®¡
   */
  getRequestStats() {
    const requests = Array.from(this.requests.values())
    const stats = {
      total: requests.length,
      success: requests.filter(r => r.status === 'success').length,
      error: requests.filter(r => r.status === 'error').length,
      pending: requests.filter(r => r.status === 'pending').length,
      averageResponseTime: 0,
      slowRequests: requests.filter(r => r.responseTime > 3000)
    }
    
    const completedRequests = requests.filter(r => r.responseTime)
    if (completedRequests.length > 0) {
      stats.averageResponseTime = completedRequests.reduce(
        (sum, r) => sum + r.responseTime, 0
      ) / completedRequests.length
    }
    
    return stats
  }
  
  private generateRequestId(): string {
    return Math.random().toString(36).substr(2, 9)
  }
}

// å…¨å±€APIè°ƒè¯•å™¨å®žä¾‹
export const apiDebugger = new ApiDebugger()
```

## é”™è¯¯å¤„ç†ç­–ç•¥

### å…¨å±€é”™è¯¯å¤„ç†
```typescript
// plugins/errorHandler.ts
interface ErrorInfo {
  error: Error
  errorInfo: string
  componentStack?: string
  context?: any
}

export class GlobalErrorHandler {
  private errorQueue: ErrorInfo[] = []
  private maxErrors = 50
  
  constructor() {
    this.setupGlobalHandlers()
  }
  
  private setupGlobalHandlers() {
    // å¤„ç†æœªæ•èŽ·çš„JavaScripté”™è¯¯
    window.addEventListener('error', (event) => {
      this.handleError({
        error: event.error || new Error(event.message),
        errorInfo: `Script error at ${event.filename}:${event.lineno}:${event.colno}`,
        context: {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno
        }
      })
    })
    
    // å¤„ç†æœªæ•èŽ·çš„Promiseæ‹’ç»
    window.addEventListener('unhandledrejection', (event) => {
      this.handleError({
        error: new Error(event.reason?.message || 'Unhandled Promise Rejection'),
        errorInfo: 'Unhandled Promise Rejection',
        context: {
          reason: event.reason,
          promise: event.promise
        }
      })
    })
  }
  
  handleError(errorInfo: ErrorInfo) {
    // æ·»åŠ åˆ°é”™è¯¯é˜Ÿåˆ—
    this.errorQueue.push({
      ...errorInfo,
      timestamp: new Date().toISOString()
    })
    
    // é™åˆ¶é”™è¯¯é˜Ÿåˆ—å¤§å°
    if (this.errorQueue.length > this.maxErrors) {
      this.errorQueue.shift()
    }
    
    // æŽ§åˆ¶å°è¾“å‡º
    console.group('âŒ Global Error')
    console.error('Error:', errorInfo.error)
    console.error('Info:', errorInfo.errorInfo)
    if (errorInfo.componentStack) {
      console.error('Component Stack:', errorInfo.componentStack)
    }
    if (errorInfo.context) {
      console.error('Context:', errorInfo.context)
    }
    console.groupEnd()
    
    // å‘é€åˆ°ç›‘æŽ§æœåŠ¡
    this.reportError(errorInfo)
  }
  
  private async reportError(errorInfo: ErrorInfo) {
    try {
      // å‘é€åˆ°Sentryæˆ–å…¶ä»–é”™è¯¯ç›‘æŽ§æœåŠ¡
      if (window.Sentry) {
        window.Sentry.captureException(errorInfo.error, {
          contexts: {
            errorInfo: errorInfo.errorInfo,
            customContext: errorInfo.context
          }
        })
      }
    } catch (err) {
      console.error('Failed to report error:', err)
    }
  }
  
  getErrorHistory() {
    return [...this.errorQueue]
  }
  
  clearErrorHistory() {
    this.errorQueue.length = 0
  }
}
```

## è°ƒè¯•æŠ€å·§å’Œæœ€ä½³å®žè·µ

### å¼€å‘çŽ¯å¢ƒè°ƒè¯•æŠ€å·§
```typescript
// å¼€å‘çŽ¯å¢ƒè°ƒè¯•åŠ©æ‰‹
export const devHelper = {
  // æŸ¥çœ‹ç»„ä»¶çŠ¶æ€
  inspectComponent(vm: any) {
    if (import.meta.env.DEV) {
      console.log('ðŸ“Š Component State:', {
        props: vm.$props,
        data: vm.$data,
        computed: Object.keys(vm.$options.computed || {}),
        methods: Object.keys(vm.$options.methods || {}),
        refs: vm.$refs
      })
    }
  },
  
  // æŸ¥çœ‹StoreçŠ¶æ€
  inspectStore(store: any) {
    if (import.meta.env.DEV) {
      console.log('ðŸª Store State:', {
        state: store.$state,
        getters: Object.keys(store._getters || {}),
        actions: Object.keys(store._actions || {})
      })
    }
  },
  
  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  async simulateNetworkDelay(ms: number = 1000) {
    if (import.meta.env.DEV) {
      console.log(`â³ Simulating ${ms}ms network delay`)
      await new Promise(resolve => setTimeout(resolve, ms))
    }
  },
  
  // æ¨¡æ‹Ÿé”™è¯¯
  simulateError(message: string = 'Simulated error') {
    if (import.meta.env.DEV) {
      throw new Error(message)
    }
  },
  
  // æ€§èƒ½æ ‡è®°
  mark(name: string) {
    if (import.meta.env.DEV && 'performance' in window) {
      performance.mark(name)
      console.log(`ðŸ“ Performance mark: ${name}`)
    }
  },
  
  // æ€§èƒ½æµ‹é‡
  measure(name: string, startMark: string, endMark: string) {
    if (import.meta.env.DEV && 'performance' in window) {
      performance.measure(name, startMark, endMark)
      const measure = performance.getEntriesByName(name)[0]
      console.log(`â±ï¸ Performance measure: ${name} = ${measure.duration.toFixed(2)}ms`)
    }
  }
}

// åœ¨å¼€å‘çŽ¯å¢ƒæš´éœ²åˆ°å…¨å±€
if (import.meta.env.DEV) {
  (window as any).devHelper = devHelper
}
```

### è°ƒè¯•æ¸…å•å’Œæµç¨‹

#### Bugä¿®å¤æµç¨‹
1. **é—®é¢˜å¤çŽ°**
   - [ ] ç¡®å®šå¤çŽ°æ­¥éª¤
   - [ ] è®°å½•çŽ¯å¢ƒä¿¡æ¯ï¼ˆæµè§ˆå™¨ã€è®¾å¤‡ã€ç½‘ç»œç­‰ï¼‰
   - [ ] æ”¶é›†é”™è¯¯æ—¥å¿—å’Œæˆªå›¾

2. **é—®é¢˜åˆ†æž**
   - [ ] æŸ¥çœ‹æŽ§åˆ¶å°é”™è¯¯ä¿¡æ¯
   - [ ] æ£€æŸ¥ç½‘ç»œè¯·æ±‚çŠ¶æ€
   - [ ] åˆ†æžç»„ä»¶çŠ¶æ€å’Œæ•°æ®æµ
   - [ ] ç¡®å®šå½±å“èŒƒå›´

3. **è§£å†³æ–¹æ¡ˆè®¾è®¡**
   - [ ] åˆ†æžæ ¹æœ¬åŽŸå› 
   - [ ] è®¾è®¡å¤šç§è§£å†³æ–¹æ¡ˆ
   - [ ] è¯„ä¼°æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹
   - [ ] é€‰æ‹©æœ€ä¼˜æ–¹æ¡ˆ

4. **ä¿®å¤å®žæ–½**
   - [ ] ç¼–å†™ä¿®å¤ä»£ç 
   - [ ] æ·»åŠ å•å…ƒæµ‹è¯•
   - [ ] è¿›è¡Œå›žå½’æµ‹è¯•
   - [ ] æ›´æ–°æ–‡æ¡£

5. **éªŒè¯å’Œå‘å¸ƒ**
   - [ ] åŠŸèƒ½éªŒè¯
   - [ ] æ€§èƒ½éªŒè¯
   - [ ] å…¼å®¹æ€§éªŒè¯
   - [ ] éƒ¨ç½²åˆ°ç”Ÿäº§çŽ¯å¢ƒ

#### å¸¸è§é—®é¢˜å¿«é€Ÿè¯Šæ–­
```typescript
// å¿«é€Ÿè¯Šæ–­å·¥å…·
export const quickDiagnostic = {
  // æ£€æŸ¥Vueåº”ç”¨çŠ¶æ€
  checkVueApp() {
    const issues = []
    
    // æ£€æŸ¥Vueç‰ˆæœ¬
    if (!window.Vue) {
      issues.push('Vueæœªæ­£ç¡®åŠ è½½')
    }
    
    // æ£€æŸ¥è·¯ç”±å™¨
    if (!window.$router) {
      issues.push('Vue Routeræœªæ­£ç¡®é…ç½®')
    }
    
    // æ£€æŸ¥çŠ¶æ€ç®¡ç†
    if (!window.$pinia) {
      issues.push('Piniaæœªæ­£ç¡®é…ç½®')
    }
    
    return issues
  },
  
  // æ£€æŸ¥ç½‘ç»œè¿žæŽ¥
  async checkNetwork() {
    const results = {
      online: navigator.onLine,
      speed: null as number | null,
      api: false
    }
    
    // æµ‹è¯•ç½‘ç»œé€Ÿåº¦
    const start = performance.now()
    try {
      await fetch('/api/health', { method: 'HEAD' })
      results.speed = performance.now() - start
      results.api = true
    } catch {
      results.api = false
    }
    
    return results
  },
  
  // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
  checkBrowserSupport() {
    const features = {
      es6: typeof Promise !== 'undefined',
      fetch: typeof fetch !== 'undefined',
      serviceWorker: 'serviceWorker' in navigator,
      localStorage: typeof Storage !== 'undefined',
      websocket: typeof WebSocket !== 'undefined'
    }
    
    const unsupported = Object.entries(features)
      .filter(([_, supported]) => !supported)
      .map(([feature]) => feature)
    
    return { features, unsupported }
  }
} 