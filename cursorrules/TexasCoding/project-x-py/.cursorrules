# ProjectX Python SDK - Cursor AI Rules

## Project Overview
This is an **async-first Python SDK** (v2.0.4) for the ProjectX Trading Platform (https://www.projectx.com/) Gateway API. It provides developers with tools to build sophisticated trading strategies and applications by offering comprehensive async access to real-time market data, order management, and market analysis. The SDK uses Polars for data processing and emphasizes performance, accuracy, and real-time capabilities.

**Important**: This is NOT a trading strategy itself - it's a development toolkit that enables the creation of trading strategies that integrate with the ProjectX platform.

**Architecture**: As of v2.0.0, this SDK is fully asynchronous with no synchronous APIs. All operations use async/await patterns for optimal performance and concurrency.

## ProjectX API Integration Rules

### Configurable Platform Endpoints
- **ALWAYS** use configuration objects for URL management
- **NEVER** hardcode platform URLs in business logic
- **ALWAYS** support both TopStepX endpoints and custom endpoints:
  - TopStepX (production): `https://rtc.topstepx.com/hubs/*`
  - Custom endpoints: user-defined URLs via `create_custom_config()`
- **PREFER** configuration helpers: `load_topstepx_config()`, `create_custom_config()`
- **ALWAYS** allow URL overrides via parameters or environment variables

### Real-time Data Payloads
- **ALWAYS** validate ProjectX payload structure before processing
- **NEVER** assume nested "data" wrapper - payloads are typically direct objects
- **ALWAYS** handle missing optional fields gracefully using `.get()` method
- **ALWAYS** validate enum values against ProjectX documentation:
  - `DomType` (0-11): Unknown=0, Ask=1, Bid=2, BestAsk=3, BestBid=4, Trade=5, Reset=6, Low=7, High=8, NewBestBid=9, NewBestAsk=10, Fill=11
  - `PositionType` (0-2): Undefined=0, Long=1, Short=2
  - `OrderStatus` (0-6): None=0, Open=1, Filled=2, Cancelled=3, Expired=4, Rejected=5, Pending=6
  - `OrderSide` (0-1): Bid=0, Ask=1
  - `TradeLogType` (0-1): Buy=0, Sell=1

### Required ProjectX Payload Fields
- **GatewayDepth**: `timestamp`, `type` (DomType), `price`, `volume`, `currentVolume`
- **GatewayQuote**: `symbol`, `lastPrice`, `bestBid`, `bestAsk`, `timestamp`
- **GatewayTrade**: `symbolId`, `price`, `timestamp`, `type` (TradeLogType), `volume`
- **GatewayUserPosition**: `id`, `accountId`, `contractId`, `type` (PositionType), `size`, `averagePrice`
- **GatewayUserOrder**: `id`, `accountId`, `contractId`, `status` (OrderStatus), `type` (OrderType), `side` (OrderSide), `size`

### Symbol Matching Rules
- **ALWAYS** use symbol ID extraction for filtering: extract base symbol from full symbol ID (e.g., "F.US.EP" from "F.US.EP.U25")
- **NEVER** use exact string matching for contract-specific symbols
- **ALWAYS** implement `_symbol_matches_instrument()` pattern for filtering

## Code Style & Formatting Rules

### Async Patterns (v2.0.0+)
- **ALWAYS** use `async def` for methods that perform I/O operations
- **ALWAYS** use `await` when calling async methods
- **ALWAYS** use `async with` for context managers
- **NEVER** create synchronous wrappers around async methods
- **ALWAYS** propagate async patterns through the entire call stack
- **PREFER** `asyncio.gather()` for concurrent operations

### Type Hints
- **ALWAYS** use modern Python 3.10+ union syntax: `int | None` instead of `Optional[int]`
- **ALWAYS** use `X | Y` in isinstance calls instead of `(X, Y)` tuples
- **ALWAYS** include comprehensive type hints for all method parameters and return values
- **PREFER** `dict[str, Any]` over `Dict[str, Any]`
- **ALWAYS** use proper async type hints: `Coroutine`, `AsyncIterator`, etc.

### Error Handling
- **ALWAYS** wrap ProjectX API calls in try-catch blocks
- **ALWAYS** log errors with context: `self.logger.error(f"Error in {method_name}: {e}")`
- **ALWAYS** return meaningful error responses instead of raising exceptions
- **NEVER** let payload validation errors crash the application

### Data Processing
- **PREFER** Polars over Pandas for all DataFrame operations
- **NEVER** include Pandas fallbacks or compatibility code
- **ALWAYS** use `with self.orderbook_lock:` for thread-safe operations
- **ALWAYS** validate DataFrame schemas before operations
- **PREFER** vectorized operations over loops when possible

## Performance & Memory Rules

### Time Filtering
- **ALWAYS** implement time window filtering for analysis methods
- **ALWAYS** filter data BEFORE processing to reduce memory usage
- **ALWAYS** provide `time_window_minutes` parameter for time-sensitive analysis
- **PREFER** recent data over complete historical data for real-time analysis

### Memory Management
- **ALWAYS** implement data cleanup for old entries
- **ALWAYS** use appropriate data types (int vs float vs str)
- **NEVER** store unnecessary historical data indefinitely
- **PREFER** lazy evaluation and streaming where possible

## Testing & Validation Rules

### Async Test Methods
- **ALWAYS** use `@pytest.mark.asyncio` for async test methods
- **ALWAYS** use `async def test_*` for testing async functionality
- **ALWAYS** include comprehensive test methods for new features
- **ALWAYS** test both success and failure scenarios
- **ALWAYS** validate prerequisites before running tests
- **ALWAYS** return structured test results with `validation`, `performance_metrics`, and `recommendations`
- **PREFER** internal test methods over external test files for component validation
- **ALWAYS** use `aioresponses` for mocking async HTTP calls

### Validation Patterns
- **ALWAYS** implement `_validate_*_payload()` methods for API data
- **ALWAYS** check for required fields before processing
- **ALWAYS** validate enum values against expected ranges
- **ALWAYS** provide clear error messages for validation failures

## Market Analysis Rules

### Indicator Implementation
- **ALWAYS** maintain talib-style function calls for indicators
- **ALWAYS** implement time filtering for all analysis methods
- **ALWAYS** return comprehensive analysis with metadata
- **PREFER** confidence scores and statistical validation over simple thresholds
- **SUPPORT** pattern recognition indicators (FVG, Order Block, WAE)
- **ENSURE** all indicators work with async data pipelines

### Data Consistency
- **ALWAYS** ensure consistent time windows across related analysis methods
- **ALWAYS** synchronize lookback periods between different analytics
- **ALWAYS** handle edge cases (empty data, insufficient history)
- **NEVER** assume data availability without validation

## Documentation Rules

### Method Documentation
- **ALWAYS** include comprehensive docstrings with Args and Returns sections
- **ALWAYS** document ProjectX API integration specifics
- **ALWAYS** include usage examples for complex methods
- **ALWAYS** document enum mappings and expected value ranges

### Code Comments
- **ALWAYS** comment complex business logic and calculations
- **ALWAYS** explain ProjectX-specific behavior and quirks
- **ALWAYS** document thread safety considerations
- **PREFER** inline comments for non-obvious operations

## Architecture Rules

### Package Structure (v2.0.4+)
- **ORGANIZED** as multi-file packages for better maintainability:
  - `client/`: Auth, HTTP, caching, rate limiting modules
  - `order_manager/`: Core, bracket orders, position orders, tracking
  - `position_manager/`: Core, risk, analytics, monitoring
  - `realtime_data_manager/`: Core, callbacks, data processing
  - `orderbook/`: Base, analytics, detection, profile
  - `utils/`: Market utils, formatting, calculations
  - `indicators/`: Momentum, overlap, volatility, volume, patterns

### Dependency Management
- **ALWAYS** use `uv` as the package manager
- **NEVER** require backwards compatibility (new project)
- **PREFER** modern Python features and syntax
- **ALWAYS** specify exact versions for critical dependencies
- **REQUIRE** Python 3.12+ for async performance

### Real-time Integration
- **ALWAYS** implement async callback patterns for real-time updates
- **ALWAYS** handle connection failures gracefully with exponential backoff
- **ALWAYS** implement proper cleanup with `async with` contexts
- **PREFER** event-driven architecture over polling
- **ALWAYS** use WebSocket for real-time data feeds
- **ENSURE** single WebSocket connection shared across managers

### Thread Safety
- **ALWAYS** use appropriate locking mechanisms
- **ALWAYS** consider concurrent access patterns
- **NEVER** modify shared data without proper synchronization
- **PREFER** immutable data structures where possible

## Specific ProjectX Considerations

### Enum Handling
- **ALWAYS** map integer enum values to semantic meanings
- **ALWAYS** handle unknown/undefined enum values gracefully
- **NEVER** assume enum values are sequential or complete
- **ALWAYS** document enum mappings in comments

### Position Management
- Position closure detection: `size == 0` (NOT `type == 0`)
- `type=0` means "Undefined" in PositionType, not closed

### Order Management
- Handle all OrderStatus values: Filled=2, Cancelled=3, Expired=4, Rejected=5, Pending=6
- Use symbolId for filtering when available

### Market Data
- Use `lastPrice`, `bestBid`, `bestAsk` from GatewayQuote
- Extract trade direction from TradeLogType enum
- Handle spread calculation and trade classification

## Code Quality Rules

### Conciseness
- **PREFER** concise code fixes over verbose explanations
- **AVOID** unnecessary code duplication
- **PREFER** helper methods for repeated logic
- **ALWAYS** consider readability vs brevity trade-offs

### Consistency
- **ALWAYS** follow established patterns within the codebase
- **ALWAYS** use consistent naming conventions
- **ALWAYS** maintain consistent error handling patterns
- **PREFER** established abstractions over new ones

## Example Patterns

### Async Context Manager Usage
```python
async def main():
    async with ProjectX.from_env() as client:
        await client.authenticate()
        
        # Use the client
        bars = await client.get_bars("MNQ", days=5)
        positions = await client.get_positions()
```

### Async Payload Validation
```python
async def _validate_quote_payload(self, quote_data: dict) -> bool:
    required_fields = ["symbol", "lastPrice", "bestBid", "bestAsk", "timestamp"]
    return all(field in quote_data for field in required_fields)
```

### Concurrent Operations
```python
async def fetch_multiple_instruments(symbols: list[str]):
    async with ProjectX.from_env() as client:
        await client.authenticate()
        
        # Fetch all instruments concurrently
        tasks = [client.get_instrument(symbol) for symbol in symbols]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        return {
            symbol: result 
            for symbol, result in zip(symbols, results)
            if not isinstance(result, Exception)
        }
```

### Time Filtering with Async
```python
async def get_analysis(self, time_window_minutes: int | None = None) -> dict[str, Any]:
    trades_to_analyze = await self.get_recent_trades()
    if time_window_minutes is not None:
        cutoff_time = datetime.now(self.timezone) - timedelta(minutes=time_window_minutes)
        trades_to_analyze = trades_to_analyze.filter(pl.col("timestamp") >= cutoff_time)
    return await self._analyze_trades(trades_to_analyze)
```

### Async Test Method Structure
```python
@pytest.mark.asyncio
async def test_feature(test_params: dict[str, Any] | None = None) -> dict[str, Any]:
    async with ProjectX.from_env() as client:
        await client.authenticate()
        
        # Validate prerequisites
        # Run tests with error handling
        # Return structured results
```

These rules ensure consistent ProjectX integration, maintain code quality, and provide clear guidance for future development. 