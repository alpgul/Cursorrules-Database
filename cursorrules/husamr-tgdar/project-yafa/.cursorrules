# Medusa 2.0 Multi-Tenant SaaS Platform - Development Rules

**IMPORTANT**: This document provides rules for building a multi-tenant SaaS platform using Medusa.js 2.0. Read and follow these guidelines strictly when developing or modifying code.

## 🚨 Critical Platform Notes

### Multi-Tenancy is NOT Native to Medusa
- **Medusa 2.0 uses a single-store model by default**
- **Multi-tenancy requires CUSTOM implementation**
- **All tenant isolation must be manually coded**

### Technology Stack (Cost-Optimized)
```yaml
Backend: Medusa.js 2.0 + TypeScript + PostgreSQL + Redis
Frontend: 
  - Admin: Medusa Vite admin (extended with custom widgets)
  - Storefront: Next.js 15 starter (existing, with multi-tenant routing)
  - Mobile: React Native + Expo (when customers request)
Infrastructure: DigitalOcean Droplet + Cloudflare Free
ORM: MikroORM (used by Medusa 2.0)
Node: 20.x (required for Medusa 2.0)
Deployment: Single droplet → revenue-based scaling
```

## 🏗️ Architecture Overview

### Finalized Architecture (Revenue-First Implementation)
**Note**: `platform.com` is a placeholder domain - replace with your actual domain throughout the implementation.

**Phase 1 (MVP - 3-4 weeks):**
- `admin.platform.com` - Unified admin for all vendors + super admin (role-based UI)
- `[vendor].platform.com` - Vendor storefronts (existing Next.js starter)
- Staff App: React Native + Expo (PWA first, then Android tablets/phones)
- Tenant-resolver middleware for multi-tenancy

**Staff App Architecture:**
- Technology: React Native + Expo (completely separate app from admin panel)
- Deployment Strategy: 
  * Phase 1: Web PWA (staff.platform.com) - Deploy first for immediate use
  * Phase 2: Android native app - Enhanced UX for tablets/phones
- Features: POS, KDS, inventory, and future staff-facing features
- Settings: Configured via admin widgets in admin.platform.com
- API Integration: Uses Medusa Store APIs with tenant-aware authentication

**Future Phases (Customer-Driven):**
- Customer portal: Dedicated myaccount.platform.com (if requested)
- Enhanced features: Based on paying customer feedback

### Data Isolation Strategy
Since Medusa doesn't provide native multi-tenancy:
1. Add `store_id` to all custom models
2. Implement tenant context middleware
3. Manually filter all queries by store
4. PostgreSQL RLS for additional security (optional)

## 📁 Project Structure

```
project-yafa/
├── core/                       # Medusa 2.0 backend
│   └── src/
│       ├── modules/            # Custom modules
│       │   ├── tenant-profile/ # Multi-tenant management
│       │   ├── platform-customer/ # Cross-store customers
│       │   ├── pos-terminal/   # POS configuration
│       │   └── restaurant-table/ # Restaurant-specific
│       ├── workflows/          # Business logic workflows
│       ├── api/               # API routes (tenant-aware)
│       ├── admin/             # Admin widgets (POS/KDS settings)
│       └── subscribers/       # Event handlers
├── storefront/                # Next.js e-commerce (existing)
└── staff-app/                 # React Native + Expo (NEW)
    ├── src/
    │   ├── screens/           # POS, KDS, Inventory screens
    │   ├── components/        # Shared UI components
    │   ├── services/          # Medusa API integration
    │   └── utils/             # Tenant-aware utilities
    ├── app.json              # Expo configuration
    ├── metro.config.js       # Metro bundler (for PWA)
    └── package.json          # Staff app dependencies
```

## 🔧 Core Development Patterns

### 1. Service Layer (Medusa 2.0 Pattern)

**ALWAYS use MedusaService - TransactionBaseService is OBSOLETE**

```typescript
// ✅ CORRECT: Medusa 2.0 Service Pattern
import { 
  MedusaService,
  InjectManager,
  InjectTransactionManager,
  MedusaContext 
} from "@medusajs/framework/utils"
import { Context } from "@medusajs/framework/types"
import { EntityManager } from "@mikro-orm/knex"
import { TenantProfile } from "./models/tenant-profile"

export class TenantProfileService extends MedusaService({
  TenantProfile
}) {
  // These methods are AUTO-GENERATED by MedusaService:
  // - createTenantProfiles(data)
  // - updateTenantProfiles(selector, data)
  // - deleteTenantProfiles(ids)
  // - retrieveTenantProfile(id, config?)
  // - listTenantProfiles(filters?, config?)
  // - listAndCountTenantProfiles(filters?, config?)

  // Custom query method
  @InjectManager()
  async findBySubdomain(
    subdomain: string,
    @MedusaContext() sharedContext?: Context<EntityManager>
  ): Promise<TenantProfile | null> {
    const manager = sharedContext?.manager
    
    const result = await manager?.findOne("TenantProfile", {
      subdomain,
      is_active: true
    })
    
    return result || null
  }

  // Transactional method
  @InjectTransactionManager()
  protected async createWithDefaults_(
    data: CreateTenantInput,
    @MedusaContext() sharedContext?: Context<EntityManager>
  ): Promise<TenantProfile> {
    const manager = sharedContext?.transactionManager!
    
    // Create tenant
    const tenant = manager.create("TenantProfile", {
      ...data,
      settings: {
        currency: "USD",
        timezone: "UTC",
        ...data.settings
      }
    })
    
    await manager.persistAndFlush(tenant)
    return tenant
  }

  // Public method that uses the transactional method
  @InjectManager()
  async createWithDefaults(
    data: CreateTenantInput,
    @MedusaContext() sharedContext?: Context<EntityManager>
  ): Promise<TenantProfile> {
    return await this.createWithDefaults_(data, sharedContext)
  }
}

// ❌ WRONG: Old Medusa v1 Pattern (DO NOT USE)
class OldService extends TransactionBaseService {
  async create(data) {
    return await this.atomicPhase_(async (manager) => {
      // This pattern is OBSOLETE in Medusa 2.0
    })
  }
}
```

### 2. Data Models (Using DML)

```typescript
// src/modules/tenant-profile/models/tenant-profile.ts
import { model } from "@medusajs/framework/utils"

export const TenantProfile = model.define("tenant_profile", {
  id: model.id().primaryKey(),
  subdomain: model.text().unique(),
  business_name: model.text(),
  business_type: model.enum(["restaurant", "retail", "hybrid"]),
  store_id: model.text(), // Links to Medusa's Store
  
  // Settings as JSON
  settings: model.json().default({}),
  
  // Multi-tenant fields
  is_active: model.boolean().default(true),
  subscription_tier: model.enum(["free", "pro", "enterprise"]).default("free"),
  
  // Timestamps auto-added by model.define()
}).indexes([
  {
    on: ["subdomain"],
    unique: true,
    where: "is_active = true"
  },
  {
    on: ["store_id"]
  }
])

// Model configuration
export default TenantProfile
```

### 3. Module Definition

```typescript
// src/modules/tenant-profile/index.ts
import { Module } from "@medusajs/framework/utils"
import TenantProfileService from "./service"

export const TENANT_MODULE = "tenantProfile"

export default Module(TENANT_MODULE, {
  service: TenantProfileService,
})
```

### 4. Workflow Pattern (ALWAYS use for complex operations)

```typescript
// src/workflows/tenant/create-vendor.ts
import { 
  createWorkflow,
  createStep,
  StepResponse,
  WorkflowResponse,
  parallelize,
  when
} from "@medusajs/framework/workflows-sdk"

// Step input types
type CreateVendorInput = {
  business_name: string
  subdomain: string
  email: string
  business_type: "restaurant" | "retail" | "hybrid"
}

// Step 1: Validate subdomain availability
export const validateSubdomainStep = createStep(
  "validate-subdomain",
  async (input: { subdomain: string }, { container }) => {
    const tenantService = container.resolve("tenantProfileService")
    
    const existing = await tenantService.listTenantProfiles({
      subdomain: input.subdomain
    })
    
    if (existing?.length > 0) {
      throw new Error(`Subdomain ${input.subdomain} is already taken`)
    }
    
    return new StepResponse(input)
  }
)

// Step 2: Create store
export const createVendorStoreStep = createStep(
  "create-vendor-store",
  async (input: CreateVendorInput, { container }) => {
    const storeService = container.resolve("storeService")
    
    const store = await storeService.createStores({
      name: input.business_name,
      supported_currencies: [
        { currency_code: "USD", is_default: true }
      ]
    })
    
    return new StepResponse(store, store.id)
  },
  // Compensation: Delete store if later steps fail
  async (storeId: string, { container }) => {
    const storeService = container.resolve("storeService")
    await storeService.deleteStores(storeId)
  }
)

// Step 3: Create tenant profile
export const createTenantProfileStep = createStep(
  "create-tenant-profile",
  async (input: { 
    vendorData: CreateVendorInput, 
    store: any 
  }, { container }) => {
    const tenantService = container.resolve("tenantProfileService")
    
    const profile = await tenantService.createTenantProfiles({
      subdomain: input.vendorData.subdomain,
      business_name: input.vendorData.business_name,
      business_type: input.vendorData.business_type,
      store_id: input.store.id,
      settings: {
        contact_email: input.vendorData.email
      }
    })
    
    return new StepResponse(profile, profile.id)
  },
  // Compensation: Delete tenant profile
  async (profileId: string, { container }) => {
    const tenantService = container.resolve("tenantProfileService")
    await tenantService.deleteTenantProfiles(profileId)
  }
)

// Main workflow
export const createVendorWorkflow = createWorkflow(
  "create-vendor",
  function (input: CreateVendorInput) {
    // Validate subdomain first
    validateSubdomainStep({ subdomain: input.subdomain })
    
    // Create store and tenant profile in parallel
    const [store] = parallelize(
      createVendorStoreStep(input),
    )
    
    const tenantProfile = createTenantProfileStep({
      vendorData: input,
      store
    })
    
    // Conditional business-type specific setup
    const setupRestaurant = when(
      { business_type: input.business_type },
      (data) => data.business_type === "restaurant"
    ).then(() => {
      // Add restaurant-specific setup steps
      // setupKitchenDisplayStep(...)
      // createDefaultMenuCategoriesStep(...)
    })
    
    return new WorkflowResponse({
      store,
      tenantProfile
    })
  }
)
```

### 5. Multi-Tenant Middleware (CRITICAL)

```typescript
// src/api/middlewares/tenant-resolver.ts
import { MedusaRequest, MedusaResponse, MedusaNextFunction } from "@medusajs/framework/http"

export async function resolveTenant(
  req: MedusaRequest,
  res: MedusaResponse,
  next: MedusaNextFunction
) {
  const hostname = req.hostname || req.get('host') || ''
  const subdomain = hostname.split('.')[0]
  
  // Skip for non-tenant routes
  if (['api', 'admin', 'superadmin', 'myaccount'].includes(subdomain)) {
    return next()
  }
  
  try {
    const tenantService = req.scope.resolve("tenantProfileService")
    const tenant = await tenantService.findBySubdomain(subdomain)
    
    if (!tenant) {
      return res.status(404).json({
        error: "Store not found"
      })
    }
    
    // CRITICAL: Set tenant context for all subsequent operations
    req.tenant = {
      id: tenant.id,
      store_id: tenant.store_id,
      subdomain: tenant.subdomain,
      business_type: tenant.business_type
    }
    
    // Set for database operations if using RLS
    if (process.env.USE_RLS === "true") {
      // This would need custom implementation
      // req.pg_context = { current_store_id: tenant.store_id }
    }
    
    next()
  } catch (error) {
    res.status(500).json({
      error: "Failed to resolve tenant"
    })
  }
}

// Apply to routes
export const config = {
  routes: [
    {
      matcher: "/store/*",
      middlewares: [resolveTenant]
    },
    {
      matcher: "/admin/*",
      middlewares: [resolveTenant]
    }
  ]
}
```

### 6. API Route Pattern

```typescript
// src/api/admin/vendors/route.ts
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http"
import { createVendorWorkflow } from "../../../workflows/tenant/create-vendor"

export async function POST(
  req: MedusaRequest<CreateVendorBody>,
  res: MedusaResponse
) {
  const { result, errors } = await createVendorWorkflow(req.scope)
    .run({
      input: {
        business_name: req.body.business_name,
        subdomain: req.body.subdomain,
        email: req.body.email,
        business_type: req.body.business_type
      }
    })
    .catch((error) => ({
      errors: [error.message],
      result: null
    }))
  
  if (errors?.length) {
    return res.status(400).json({ errors })
  }
  
  res.status(201).json({ vendor: result })
}

// Validation
type CreateVendorBody = {
  business_name: string
  subdomain: string
  email: string
  business_type: "restaurant" | "retail" | "hybrid"
}
```

### 7. Module Links (Cross-Module Relations)

```typescript
// src/links/store-tenant.ts
import { defineLink } from "@medusajs/framework/utils"
import StoreModule from "@medusajs/medusa/store"
import TenantModule from "../modules/tenant-profile"

// One store has one tenant profile
export default defineLink(
  StoreModule.linkable.store,
  TenantModule.linkable.tenantProfile,
  {
    linkable: {
      id: "store_tenant_link",
      deleteCascade: true
    }
  }
)
```

### 8. Query Usage (With Tenant Context)

```typescript
// Always include tenant filtering when using Query
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http"

export async function GET(
  req: MedusaRequest,
  res: MedusaResponse
) {
  const query = req.scope.resolve("query")
  
  // CRITICAL: Always filter by tenant
  const { data } = await query.graph({
    entity: "product",
    fields: ["id", "title", "variants.*"],
    filters: {
      // Manual tenant filtering required
      store_id: req.tenant?.store_id
    },
    pagination: {
      skip: 0,
      take: 20
    }
  })
  
  res.json({ products: data })
}
```

### 9. Subscriber Pattern

```typescript
// src/subscribers/tenant-created.ts
import { SubscriberArgs, SubscriberConfig } from "@medusajs/framework"

export default async function handleTenantCreated({
  event,
  container
}: SubscriberArgs<{ id: string }>) {
  const logger = container.resolve("logger")
  const emailService = container.resolve("emailService")
  
  logger.info(`New tenant created: ${event.data.id}`)
  
  // Send welcome email
  await emailService.send({
    template: "vendor-welcome",
    to: event.data.contact_email,
    data: {
      store_url: `https://${event.data.subdomain}.platform.com`,
      admin_url: `https://admin.platform.com`,
      staff_app_url: `https://staff.platform.com` // PWA version
    }
  })
}

export const config: SubscriberConfig = {
  event: "tenant.created"
}
```

## 🔒 Security Patterns

### Manual Tenant Isolation

Since Medusa doesn't provide native data isolation:

```typescript
// ALWAYS filter by tenant in custom queries
class CustomProductService extends MedusaService({
  CustomProduct
}) {
  @InjectManager()
  async listForTenant(
    tenantId: string,
    filters: any = {},
    @MedusaContext() sharedContext?: Context<EntityManager>
  ) {
    // CRITICAL: Always include tenant filter
    return await this.listCustomProducts({
      ...filters,
      tenant_id: tenantId // Manual tenant filtering
    }, undefined, sharedContext)
  }
}
```

### PostgreSQL RLS (Optional Enhanced Security)

```sql
-- migrations/add-rls-policies.sql
-- This is CUSTOM implementation, not provided by Medusa

-- Enable RLS on custom tables
ALTER TABLE custom_product ENABLE ROW LEVEL SECURITY;
ALTER TABLE vendor_order ENABLE ROW LEVEL SECURITY;

-- Create security policies
CREATE POLICY tenant_isolation ON custom_product
  FOR ALL 
  USING (store_id = current_setting('app.current_store_id', true)::text);

-- Function to set context
CREATE OR REPLACE FUNCTION set_current_store_id(store_id text)
RETURNS void AS $$
BEGIN
  PERFORM set_config('app.current_store_id', store_id, true);
END;
$$ LANGUAGE plpgsql;
```

## 🚫 Anti-Patterns to Avoid

### ❌ DON'T: Use Old Service Patterns
```typescript
// ❌ WRONG - Medusa v1 pattern
export class MyService extends TransactionBaseService {
  async create(data) {
    return await this.atomicPhase_(async (manager) => {
      // DON'T use atomicPhase_ - it's obsolete
    })
  }
}

// ❌ WRONG - Direct repository access
const repo = this.activeManager_.withRepository(this.myRepository_)
```

### ❌ DON'T: Skip Tenant Filtering
```typescript
// ❌ WRONG - Returns data from ALL tenants
const products = await productService.listProducts()

// ✅ CORRECT - Filter by tenant
const products = await productService.listProducts({
  store_id: req.tenant.store_id
})
```

### ❌ DON'T: Modify Medusa Core Tables
```typescript
// ❌ WRONG - Never alter Medusa's tables
ALTER TABLE store ADD COLUMN subdomain TEXT;

// ✅ CORRECT - Create linking tables
CREATE TABLE tenant_profile (
  id TEXT PRIMARY KEY,
  store_id TEXT REFERENCES store(id),
  subdomain TEXT UNIQUE
);
```

### ❌ DON'T: Skip Workflows for Complex Operations
```typescript
// ❌ WRONG - Direct service calls
async function createVendor(data) {
  const store = await storeService.create(data)
  const tenant = await tenantService.create({ store_id: store.id })
  // No atomicity, no rollback!
}

// ✅ CORRECT - Use workflows
const result = await createVendorWorkflow(container).run({ input: data })
```

## 🧪 Testing Patterns

### Unit Tests
```typescript
import { createMockContainer } from "@medusajs/test-utils"

describe("TenantProfileService", () => {
  it("should create tenant with defaults", async () => {
    const container = createMockContainer()
    const service = container.resolve("tenantProfileService")
    
    const tenant = await service.createWithDefaults({
      subdomain: "test-store",
      business_name: "Test Store",
      business_type: "retail"
    })
    
    expect(tenant.settings.currency).toBe("USD")
    expect(tenant.subdomain).toBe("test-store")
  })
})
```

### Workflow Tests
```typescript
describe("createVendorWorkflow", () => {
  it("should rollback on failure", async () => {
    const { result, errors } = await createVendorWorkflow(container)
      .run({
        input: {
          subdomain: "existing-subdomain", // Will fail validation
          // ...
        }
      })
      .catch(e => ({ errors: [e], result: null }))
    
    expect(errors).toHaveLength(1)
    // Verify rollback occurred
  })
})
```

## 🎨 Admin UI Customization

### Custom Widget
```typescript
// src/admin/widgets/tenant-info.tsx
import { defineWidgetConfig } from "@medusajs/admin-shared"

const TenantInfoWidget = () => {
  const { tenant } = useAdminCustomQuery("/admin/current-tenant")
  
  return (
    <Container>
      <Heading>Current Store: {tenant?.business_name}</Heading>
      <Badge>{tenant?.subscription_tier}</Badge>
    </Container>
  )
}

export const config = defineWidgetConfig({
  zone: "order.list.before"
})

export default TenantInfoWidget
```

## 📝 Configuration

### medusa-config.ts
```typescript
import { defineConfig } from '@medusajs/framework/utils'

export default defineConfig({
  projectConfig: {
    databaseUrl: process.env.DATABASE_URL,
    http: {
      jwtSecret: process.env.JWT_SECRET,
      cookieSecret: process.env.COOKIE_SECRET,
      cors: {
        origin: process.env.CORS_ORIGIN?.split(",") || [
          "http://localhost:3000",
          "https://*.platform.com"
        ]
      }
    }
  },
  modules: [
    {
      resolve: "./src/modules/tenant-profile"
    },
    {
      resolve: "./src/modules/platform-customer"
    },
    // Medusa's default modules
    {
      resolve: "@medusajs/medusa/store"
    },
    {
      resolve: "@medusajs/medusa/auth"
    }
  ]
})
```

## 🚀 Deployment Considerations (Cost-Optimized)

### Infrastructure Strategy
1. **Start Simple**: Single DigitalOcean droplet ($48/month)
2. **Database**: PostgreSQL on same machine with RLS
3. **Scaling Triggers**: 
   - $1,000 MRR: Add staging environment (+$52/month)
   - $3,000 MRR: Managed database (+$50-100/month)
   - $5,000 MRR: Consider mobile app development
4. **Monitoring**: Cloudflare Free + Sentry (when needed)
5. **SSL**: Wildcard via Cloudflare for *.platform.com

### Current Cost Structure
- **Validation Phase**: ~$52/month (droplet + backups)
- **Growth Phase**: ~$78/month (+ Sentry)
- **Scale Phase**: $150-300/month (+ staging + managed services)

## 📚 Key Principles

### Core Development Rules
1. **Always use workflows** for multi-step operations
2. **Always include tenant context** in queries
3. **Always use MedusaService** pattern (not TransactionBaseService)
4. **Always include compensation** in workflow steps
5. **Never modify Medusa core** - extend via modules
6. **Never trust subdomain alone** - validate tenant status
7. **Test rollback scenarios** in workflows
8. **Document custom patterns** since multi-tenancy isn't native

### Revenue-First Development Strategy
9. **Optimize for first paying customer**, not perfect architecture
10. **Accept technical debt** that accelerates customer acquisition
11. **Document all shortcuts** for systematic cleanup post-revenue
12. **Never compromise** on data security or tenant isolation
13. **Build mobile apps** only when customers request them
14. **Use existing Medusa capabilities** before building custom solutions

### Implementation Priorities (3-4 Week Timeline)
**Week 1-2 (Critical Foundation):**
- Tenant-resolver middleware (enables all multi-tenancy)
- Tenant-profile module (links to Medusa stores)
- Basic tenant isolation in existing API routes

**Week 3-4 (Business Logic):**
- POS/KDS modules in core/src/modules/
- Admin widgets for vendor configuration
- Mobile app (only if customers request)

## 📝 Technical Debt Documentation

### ALWAYS Document Shortcuts
When taking ANY technical shortcut during development:

1. **Add immediately to `prd/TECHNICAL_DEBT.md`:**
```markdown
### TD-XXX: [Brief Description]
**Date**: YYYY-MM-DD  
**Reason**: Why this shortcut was necessary  
**What we did**: The actual shortcut/quick fix  
**Risks**: What could go wrong  
**Proper fix**: What should be done eventually  
```

2. **Add TODO comment in code:**
```typescript
// TODO: TD-XXX - [Brief description]
// See prd/TECHNICAL_DEBT.md#TD-XXX for details
[shortcut code here]
```

### When to Document Debt
Document when you:
- Skip proper error handling for speed
- Use hardcoded values instead of configuration  
- Skip tests to meet a deadline
- Copy-paste code without refactoring
- Implement workarounds instead of proper solutions
- Skip tenant isolation for quick testing

### Critical Rule
**NEVER take shortcuts with data security or tenant isolation without documenting the risk.**

---

**Remember**: This is a CUSTOM multi-tenant implementation on top of Medusa 2.0. Medusa provides the framework, but tenant isolation, RLS, and multi-store routing are custom implementations that must be carefully maintained. **Focus on revenue generation over architectural perfection.**